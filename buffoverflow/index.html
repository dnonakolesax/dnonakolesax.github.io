<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Как система, процессор и компилятор стреляют нам в ноги раньше хакеров</title>
	<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.5.1/styles/github.min.css">
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 10px 0 10px 0;
        }
		img {
			width: 100%
		}
        #html-output {
            margin-bottom: 20px;
			margin-left: auto;
			margin-right: auto;
			width: 40vw;
			border: 1px solid gray;
			border-radius:12px;
			padding-left: 10px;
			padding-right: 10px;
        }
		
		@media (max-width: 768px) {
			#html-output {
				width: 90vw !important;
			}
		}
    </style>
</head>
<body>
    <div id="html-output"></div>
	<script src="https://cdn.jsdelivr.net/npm/marked/lib/marked.umd.js"></script>
	<script src="https://cdn.jsdelivr.net/npm/marked-highlight/lib/index.umd.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.5.1/highlight.min.js"></script>
    <script>
        function convertMarkdown() {
			const { Marked } = globalThis.marked;
			const { markedHighlight } = globalThis.markedHighlight;
            const markdown = `# Как компилятор и система защищают разработчиков от выстрелов в ноги

[Назад](https://dnonakolesax.github.io/index.html)

Подготовка блока про [основы безопасности](https://dnonakolesax.github.io/sec) показала, что классические для C/C++ и прочих memory-unsafe языков уязвимости всё ещё являются одними из самых популярных. По состоянию на 2025 год, к ним относятся:
- 5 место - CWE-787 Out-of-bounds Write (в 2024 - 3 место)
- 7 место - CWE-416 Use After Free (в 2024 - 8 место)
- 8 место - CWE-125 Out-of-bounds Read (в 2024 - 6 место)
- 11 место - CWE-120 Buffer Copy without Checking Size of Input 
- 14 место - CWE-121 Stack-based Buffer Overflow
- 16 место - CWE-122 Heap-based Buffer Overflow

CWE-120-122 отсутствовали в 2024, для них был общий класс CWE-119 Improper Restriction of Operations within the Bounds of a Memory Buffer (20 место)


Несмотря на то, что в последнее время всё больше софта пишется на memory-safe языках, эти уязвимости всё ещё удерживают высокие позиции. Здесь можно выделить следующие причины:
- Огромное количество легаси-кода C/C++
- Memory-safe языки также могут полагаться на C/C++ (хотя и размер и опыт коммьюнити быстро отлавливает подобные проблемы в языках)
- Многие вещи просто нельзя переписать на другие языки
- Некоторые способы защиты превращают RCE в DOS: безопаснее, но всё ещё проблема 
- Шаловливые ручки Go-разработчиков лезут в unsafe (подставьте сюда свой основной язык и соответствующий пакет)

Разработчики операционных систем, компиляторов и даже процессоров тоже заинтересованы в повышении безопасности своего продукта, поэтому постоянно добавляют способы выстрелить в колени разработчику прежде, чем это сделает человек с недобрыми намерениями. Рассмотрим самые базовые из них.

## Прошлое атак с переполнением буфера

### Первая судимость за программу

В 1986 году конгресс США принял The Computer Fraud and Abuse Act of 1986. Этот закон первым в истории Штатов определил список преступлений, связанных с компьютерами и неавторизованным доступом к ним. В 1989 году состоялось первое заседание, связанное с нарушением этого закона. В качестве подсудимого оказался аспирант факультета вычислительной техники Корнеллского университета Роберт Т. Моррис, который в 1988 году запустил один из самых первых известных вирусов - червь Морриса. Вирус содержал несколько векторов атаки, но мы рассмортим только ту часть, которая была связана с переполнением буфера.

В конце восьмидесятых на большинстве компьютеров, имевших доступ в интернет, был установлен finger-сервер. Протокол finger позволял узнать информацию о пользователях удалённого компьютера: кто сейчас в системе, имя/учётка, когда входил, иногда телефон/офис, а также содержимое пользовательских файлов .plan и .project. Клиентская программа finger открывала TCP-соединение на порт 79 удалённого хоста и отправляла одну строку запроса (например, имя пользователя или пустую строку), а сервер (демон fingerd) формировал текстовый ответ и закрывал соединение. Сейчас такое представить невозможно, потому что это нарушает все мыслимые и немыслимые протоколы безопасности, но тогда, когда интернет был маленьким и ламповым, это было в порядке вещей. 

Именной в этой утилите разработчики допустили фатальную ошибку. Данные, которые присылались пользователем, [обрабатывались функцией gets](https://github.com/dnonakolesax/fingerd-bsd-43/blob/f10fb3282c60b0d63e641e2f1802051076f2240f/fingerd.c#L67) и [помещались в буфер с фиксированным размером 512](https://github.com/dnonakolesax/fingerd-bsd-43/blob/f10fb3282c60b0d63e641e2f1802051076f2240f/fingerd.c#L57). Главной уязвимостью функции gets являлось то, что она не учитывала размер массива: запись в память проводилась до нулевого байта. Таким образом, если пользователь пришлёт сообщение размером более 512 байт и без \0, функция gets перезапишет чужую область в памяти. Таким образом, клиент имеет полный доступ к памяти процесса. 

Если вы понимаете, как устроены компиляторы, то знаете, что у функции есть обязательные пролог и эпилог. В эпилоге содержатся восстановление значений регистров, очистка стека, а также информация о том, какой код выполнять дальше, после возврата из функции. Соответственно, зная точное расположение адреса возврата (для этого нужно знать архитектуру и ОС, на которой работает сервер), можно его перезаписать, чтобы он выполнил любой код, например тот, который мы пришлём серверу. Именно это и делал червь Морриса. Вместо 512 байт, он посылал 536: 6 слов по 4 байта записывались за пределы массива line[512]. Моррис подобрал такую строку, которая позволила выполнить присланное где-то в середине строки "execve /bin/sh". Теперь, когда он отправлял последующие сообщения, все они выполнялись в консоли заражённого компьютера. Поскольку тогда никто не думал о запуске серверов от имени непривелегированных пользователей, фактически он получал доступ к удалённой машине.

Жертвой вируса стали компьютеры VAX-11/780 (представлен на фото), работавшие на BSD 4.3. ![](https://cds.cern.ch/record/2273210/files/OBJ-IT-025.jpg) Червём Морриса было заражено порядка 6000 машин из ~60000 всего, т. е. около 10% интернета.

Уязвимость в fingerd была не единственной, на которую полагался червь. Он использовал уязвимость отладочного режима Sendmail, которая точно также позволяла выполнять удалённые команды. К некоторым устройствам он подключался через rsh/rexec (небезопасные прародители сегодняшнего ssh): какие-то из заражённых компьютеров оказывались доверенными и могли спокойно подключаться другим, а от каких-то он просто угадывал пароль. Про энтропию пароля тогда никто не думал, поэтому он мог спокойно совпадать с именем пользователя. Можно посмотреть [список](https://github.com/khakimov/morris/blob/da47a4d6941089566f0a538dbe4208d0b01343f4/cracksome.c#L270), который использовался для подбора: там всего порядка 400 значений (сравните хотя бы с тем же rockyou.txt)

Ошибка была и в самом черве: Моррис случайно (если верить его словам) сделал из него форк-бомбу. Червь повторно заражал уже взломанные компьютеры, из-за чего занимал всё процессорное время, что приводило к DoS (Denial of Service). Сам автор заверял, что хотел всего лишь привлечь внимание людей к проблеме сетевой безопасности, а не положить на неизвестное время десятую часть интернета.

Ущерб от червя было оценить сложно. Называются разные цифры: от ста тысяч до десяти миллионов долларов. Роберту Моррису грозило до 5 лет лишения свободы, а также до четверти миллиона долларов штрафа. В 1990 году его приговорили к трём годам условно и 400 часам обязательных работ, а также заставили выплатить штраф в размере $10,000 и $3,276 расходов на условный срок.   

История оказалась поучительной и заставила людей задуматься о том, что интернет не так безопасен, как им кажется. Управление перспективных исследовательских проектов Министерства обороны США (DARPA) вскоре после атаки создала координационный центр CERT (computer emergency response team) - основной координационный центр по решениям проблем безопасности в интернете. Заражение такого масштаба подтолкнуло людей к выработке болеё жёстких норм безопасности, разработки программ и выбора паролей. Вместе с тем, инцидент открыл и новое пространство для работы хакеров. Вирус навсегда вписал себя в самые первые страницы истории кибербеза, интернета и всего компьютерного мира в целом, а дискета с его исходным кодом хранитс в Музее компьютерной истории в Кремниевой долине. ![](https://ru.wikipedia.org/wiki/%D0%A7%D0%B5%D1%80%D0%B2%D1%8C_%D0%9C%D0%BE%D1%80%D1%80%D0%B8%D1%81%D0%B0#/media/%D0%A4%D0%B0%D0%B9%D0%BB:Morris_Worm.jpg)

Более подробно можно прочитать [здесь(исходники червя)](https://github.com/khakimov/morris/blob/da47a4d6941089566f0a538dbe4208d0b01343f4/hs.c#L665C21-L665C36) и [здесь(RFC 1135, изданный после расследования атаки)](https://www.rfc-editor.org/rfc/rfc1135) 

### SQL Slammer

Чем дальше во временной эпохе, тем сложнее искать информацию о каких-либо атаках, особенно если это касается разработок крупных компаний по типу Microsoft. Тем не менее, даже такой гигант смог допустить фатальную ошибку в своём продукте.

В 2002 году была обнаружена уязвимость [CVE-2002-0649](https://nvd.nist.gov/vuln/detail/CVE-2002-0649). Её нашли "белые хакеры", так что никакой атаки за этим не последовало. Сообщалось, что в Microsoft SQL Server Resolution Service на порту 1434 (UDP) для msg_type 0x04 и 0x08 имеются уязвимости, связанные с переполнением буфера. Miscrosoft выпустила [оповестила пользователей, а затем и выпустила патч](https://learn.microsoft.com/en-us/security-updates/securitybulletins/2002/ms02-039), исправляющий данную уязвимость. Однако одно дело - выпустить патч, а другое - убедить пользователей обновиться...

Поскольку это Micro~~slop~~soft, никаких исходных кодов уязвимого сервиса мы уже не получим. Тем не менее, предлагаю немного разобраться, что такое Microsoft SQL Server Resolution Service, какие запросы к нему посылались по UDP на порт 1434 и что за msg_type 0x04 (червь использовал именно этот).

Microsoft SQL Server Resolution service помогал узнать, на каких портах запущены инстансы Microsoft SQL Server. Поскольку их могло быть несколько, а порты выделялись динамически, нужен был отдельный сервис, который расскажет что и как. В корпоративных сетях потери считались небольшими, поэтому решили использовать UDP. Важно заметить, что сервис предназначался для КОРПОРАТИВНЫХ СЕТЕЙ, а не должен был торчать наружу в глобальный интернет, но закрывать порты забывают даже сейчас, чего уж говорить про 2003 год. msg_type 0x04 означал, что пользователю нужно дать информацию о конкретном инстансе, имя которого он передаёт в строке не более 32 байт.

Естественно, эти 32 байта никто не проверял, из-за чего можно было повторить старую атаку червя Морриса: переписать адрес возврата на строку, в которой определить необходимые вызовы. В архиве сохранились [исходники](https://web.archive.org/web/20110722191923/http://www.eeye.com/html/Research/Flash/sapphire.txt) червя, так что его можно изучить подробнее. Он написан на ассемблере, зато очень компактный (далее мы убедимся, что это очень полезное свойство). Кроме того, там есть подробные комментарии на английском. Итак, основной алгоритм:

1. Переписываем возврат функции на стек самой функции: push    42B0C9DCh       ; [RET] sqlsort.dll -> jmp esp
2. Собираем payload
2. Загружаем необходиые DLL-библиотеки и узнаём адреса функций (именно поэтому он такой лёгкий). SQL Server сам использует данные DLL, так что по этим адресам можно будет спокойно общаться на удалённых машинах
3. Создаём UDP-сокет
4. Рассылаем нашего червя по псевдослучайно сгенерированным адресам

376 байт помещаются в одну UDP-датаграмму. В отличие от червя Морриса, ему не нужно прятаться в системе, так как он целиком и полностью исполняется внутри SQL-сервера. Если перезапустить сервер, через какое-то время машина будет заражена снова.

Атака началась 25 января 2003 года. В отличие от червя Морриса, SQL Slammer не скрывал в себе форк-бомбы. У него вообще не было никакой вредоносной нагрузки - он просто распространялся дальше. Но из-за масштабов сканирования случайных адресов в поисках новых SQL-серверов начали перегружаться сетевые устройства. В результате, многие системы начали выходить из строя: не работали банкоматы, отменялись авиарейсы, а в штате Вашингтон упали сервера службы 911. На рисунках ниже показано, что менее, чем за полчаса, было заражено около 75 тысяч серверов (представлены карты заражений по состоянию на 25.01.2003 05:29 и 06:00 UTC).

![](https://www.caida.org/catalog/papers/2003_sapphire/sql-before.gif)
![](https://www.caida.org/catalog/papers/2003_sapphire/sql-after.gif)

Поскольку автор червя неизвестен (по стилю исходного кода подозревают, что их было несколько), никакой ответственности никто не понёс. 

### Blaster / MSBlast

И снова Microsoft, только теперь уже ошибка была допущена в Windows 2000 и Windows XP (а вот в Windows Server 2003 уже были защиты от переполнения стека, так что он устоял). Как и в случае с SQL Slammer, белые хакеры заранее нашли и обнаружили уязвимость [CVE-2003-0352](https://nvd.nist.gov/vuln/detail/CVE-2003-0352) в RPC/DCOM сервисах Windows, а Microsoft [выпустила уведомление и исправление](https://learn.microsoft.com/en-us/security-updates/securitybulletins/2003/ms03-026). Если в прошлом случае речь шла об SQL-серверах, которые не нужны простому пользователю, то теперь уязвимость нашлась в операционных системах, установленных на домашних компьютерах, что резко расширяло круг атаки и усложняло процесс патчинга, так как если в компании есть специально обученный человек, ответственный за обновление софта до актуальных версий, то заставить частное лицо обновиться - отдельный челлендж. Кроме того, в те времена у большинства пользователей был "белый IP", так что открытый порт на домашнем ПК был сразу же доступен всему интернету.

Не будем останавливаться на [исходниках](https://gist.github.com/yorickdewid/a9fb98da3c367b360e36#file-blaster-c), так как ничего принципиально нового здесь уже не увидеть, хотя в начале есть довольно-таки интересный комментарий. А ещё там можно заметить резонные вопросы к Биллу Гейтсу. ![](blaster_billy.png)

Итак, сценарий простой:
- Через редактор реестра записываемся в автозапуск под именем "windows auto update". Создаём mutex с именем "BILLY" (опять привет Гейтсу), чтобы не заражать один и тот же комп повторно (последующие такие же процессы не смогут захватить мьютекс и завершатся).
- Начинаем смотреть, до кого в локальной и глобальной сети можно достучаться по уязвимому порту 135 (TCP) (порт для уязвимой службы, который мог быть виден в сеть с домашнего компа)
- На все адреса, с которыми удалось установить соединение, посылаем эксплойт. Эксплойт стандартный - переполнение буфера, перехват возврата, вредоносный код
- Вредоносный код поднимает удалённый shell на порту 4444 (TCP)
- Если удалось получить доступ к shell, поднимаем на машине жертвы TFTP сервер, скачиваем эксплойт и запускаем его. TFTP сервер живёт только во время передачи, так что у вас есть примерно 20 секунд на его обнаружение
- Помимо основной функции, червь пытался DoSить сервера обновлений Windows с заражённых машин с помощью SYN-flood (почитайте как работает TCP, если не знаете, что такое SYN), но не получилось, так как был атакован windowsupdate.com, являющийся простым редиректом на windowsupdate.microsoft.com.

Всего было заражено порядка трёхсот тысяч машин. Червь крашил пользователям RPC сервис, из-за чего их компьютеры постоянно перезапускались, однако главной идеей была атака на сервера Microsoft в полночь 16 августа 2003 года (в исходниках можно увидеть соответствующие временные метки), т. е. заражённые компьютеры становились всего лишь инструментами новой атаки. Microsoft среагировала вовремя, и главная часть замысла злодеев не состоялась. Тем не менее, ущерб от простоя оценивается в сотни миллионов долларов, а червь заодно успел ещё и вызвать [блэкаут на северо-востоке США](https://en.wikipedia.org/wiki/Northeast_blackout_of_2003).

В сентябре 2003 года был задержан американский школьник Джеффри Ли Парсон. Ему предъявили обвинение в создании вируса Blaster.Подростку грозило от 18 до 37 месяцев тюрьмы и штраф до пятисот тысяч долларов. Однако Microsoft попросила заменить штраф на общественные работы. Судья посчитала главной причиной преступления дурное воспитание и недостаточный надзор со стороны родителей, потому окончательным вердиктом стало полтора года тюрьмы (уже не условно, как с fingerd) и 225 часов исправительных работ. 

На суде Парсон заявил, что не создавал Blaster, а всего лишь внёс небольшие изменения и начал рассылку своей версии. Он отредактировал несколько текстовых строчек в исходном вирусе, заменив их на свои послания, а также попытался приклеить к нему скачанный из интернета бэкдор, чтобы иметь доступ к заражённым компьютерам. С большой вероятностью, это заявление было правдой. 5 ноября 2003 года Microsoft назначила награду в размере $250,000 за поимку создателя вируса Blaster, но его так никто и не нашёл.

У Blaster был и противник - полезный червь [Welchia](https://en.wikipedia.org/wiki/Welchia). Пользуясь той же уязвимостью, что и Blaster, он определял, заражён ли компьютер, удалял Blaster и скачивал соответствующие патчи.


## Модель памяти Linux

Поскольку большинство серверных приложений крутится на Linux, рассматривать будем именно его. Linux использует виртуальную память: каждый процесс видит своё адресное пространство, а ядро через MMU и таблицы страниц отображает виртуальные адреса на физическую RAM, файл подкачки (swap) и memory-mapped файлы. Это даёт изоляцию процессов, защиту, ленивую загрузку страниц и эффективное разделение одних и тех же данных/кода.

### Kernel space / User space

Память в Linux делится на два пространство: пользовательское (user) и ядро (kernel)

В пользовательском пространстве выполняются все наши программы. Они запускаются в непривелегированном режиме (в архитектуре x86 - ring3, запрет доступ к I/O и физической памяти). Процессы ограничены своими адресными пространствами и правами страниц (rwx) и могут получить доступ к I/O, управлению процессами, сети, файлам только через syscall и файловые интерфейсы

В пространстве ядра работает само ядро, драйверы и подсистемы(планировщик, сеть, etc). Оно работает в привелегированном режиме (в архитектуре x86 - ring0) и имеет полный доступ к аппаратуре: управление памятью (MMU), прерывания, устройства, планирование, сети, может читать/писать любую физическую память. Страницы ядра ограничены правами доступа для user space, но при этом нужны для обработки прерываний и сисколлов.

ring2 и ring1 предполагалось использовать для драйверов устройств, но на практике они простаивают, чтобы не нагружать систему лишними переключениями.

### Сегменты памяти процесса

Выделим основные интересные для нас сегменты процесса: text, rodata, data, bss, heap, stack, mmap. Все программы для демонстрации будем компилировать с флагом -no-pie (расскажу что позже что это за PIE).

#### Text

Машинные инструкции программы. У процесса есть права только на чтение и исполнение (r-x). Может разделяться между процессами (один и тот же исполняемый файл/библиотека).

Реализуем следующую функцию на языке C и посмотрим её адрес:

\`\`\`c
__attribute__((noinline))
int text_func(int x) {
    return x * 3 + 1;
}
...
int main() {
    printf("=== Addresses ===\n");
    printf(".text: text_func = %p\n", (void*)&text_func);
}
\`\`\`
Отключим встраивание (\_\_attribute\_\_((noinline))), чтобы компилятор выделил её именно как отдельную функцию, а не просто встроил её код в места вызова. 
Адрес функции: 0x4011f6
Посмотрим, какой адрес у блока .text с помощью команды (для data, rodata, bss подставляйте в греп соответствующее название):
\`\`\`sh
readelf -S ./mem_layout_demo | grep '\.text'  
\`\`\`
Получим следующий результат:
\`\`\`sh
  [13] .text             PROGBITS         0000000000401110  00001110
\`\`\`
Действительно, такой блок существует и начинается с виртуального адреса 0x401110. PROGBITS означает, что секция имеет байты в файле (её можно прочитать из ELF).
Посмотрим на маппинги процесса через /proc/\${pid}/maps:

\`\`\`sh
00401000-00402000 r-xp 00001000 08:30 2375527 /root/noted-exps/linux_mem/mem_layout_demo
\`\`\`

В нашем случае текстовая секция занимает ровно одну страницу в памяти (0x1000 = 4096, размер страницы можно узнать через getconf PAGESIZE, у меня - 4096). Как и ожидалось, мы не можем её перезаписывать: только читать и исполнять. 2375527 - номер Inode файла с нашим бинарником, далее его имя (включая полный путь).

#### rodata (константы)

Read-only данные. Код на Си:

\`\`\`c
static const char *g_ro_str = "RODATA: string literal";
...
int main() {
    printf(".data : g_ro_str (ptr var) = %p\n", (void*)&g_ro_str);
    printf(".rodata : g_ro_str (points to) = %p\n", (void*)g_ro_str);
}
\`\`\`

Адрес переменной (указатель): 0x4040a0 
Адрес куда указывает: 0x402008

Адрес блока: .rodata           PROGBITS         0000000000402000  00002000

Маппинг: 00402000-00403000 r--p 00002000 08:30 2375527                            /root/noted-exps/linux_mem/mem_layout_demo

Как и ожидалось, доступ только на read.

В дампе памяти (оффсеты начиная с 0x402000):

00000000: 0100 0200 0000 0000 524f 4441 5441 3a20  ........RODATA:               
00000010: 7374 7269 6e67 206c 6974 6572 616c 0050  string literal.P

#### data 

Инициализированные глобальные / статические переменные. Код на Си:

\`\`\`c
int g_data = 0x11223344;
static uint8_t g_data_arr[16] = {0,1,2,3,4,5,6,7,8,9,0xaa,0xbb,0xcc,0xdd,0xee,0xff};
...
int main() {
    printf(".data : g_data = %p\n", (void*)&g_data);
    printf(".data : g_data_arr = %p\n", (void*)g_data_arr);
}
\`\`\`


Адрес переменной g_data: 0x404080
Адрес переменной g_data_arr: 0x404090

Адрес блока: .data             PROGBITS         0000000000404070  00003070

Маппинг: 00404000-00405000 rw-p 00003000 08:30 2375527                            /root/noted-exps/linux_mem/mem_layout_demo

Доступ на чтение и запись (rw-p). P означает, что результат записи не будет шариться между процессами (например, если запустить 2 такие программы).

В дампе памяти (оффсеты начиная с 0x404000):

00000080: 4433 2211 0000 0000 0000 0000 0000 0000  D3".............                                         
00000090: 0001 0203 0405 0607 0809 aabb ccdd eeff  ................

Здесь же можно найти указатель на rodata из прошлого пункта (напомню, он указывает на адрес: 0x402008, а его адрес - 0x4040a0):

000000a0: 0820 4000 0000 0000 0000 0000 0000 0000  . @.............

#### bss

Неинициализированные глобальные / статические переменные. Код на Си:

\`\`\`c
int g_bss;
static uint8_t g_bss_arr[4096]; 
...
int main() {
    printf(".bss : g_bss = %p\n", (void*)&g_bss);
    printf(".bss : g_bss_arr = %p\n", (void*)g_bss_arr);
}
\`\`\`

Адрес переменной g_bss: 0x4040e0
Адрес переменной g_bss_arr: 0x404100

Адрес блока: .bss              NOBITS           00000000004040c0  000030a8

NOBITS означает, что секция не хранит байты в файле (в файле место под неё не выделено), но при загрузке в память для неё выделяется диапазон и он обнуляется.

Маппинг: 00404000-00405000 rw-p 00003000 08:30 2375527                            /root/noted-exps/linux_mem/mem_layout_demo

Те же адреса, что и для .data.

В дампе памяти (оффсеты начиная с 0x404000):

000000e0: 0000 0000 0000 0000 0000 0000 0000 0000  ................

000000f0: 0000 0000 0000 0000 0000 0000 0000 0000  ................

00000100: 0000 0000 0000 0000 0000 0000 0000 0000  ................

00000110: 0000 0000 0000 0000 0000 0000 0000 0000  ................

00000120: 0000 0000 0000 0000 0000 0000 0000 0000  ................

и далее одни нули...

#### heap (куча)

Динамическая память, выделяемая с помощью malloc и new. Растёт вверх (к большим адресам) в классической модели. Реально аллокатор может брать память через системные brk/sbrk и/или через mmap.

\`\`\`c
int main() {
    size_t heap_sz = 0x2000;
    uint8_t *heap_buf = (uint8_t*)malloc(heap_sz);
    if (!heap_buf) { perror("malloc"); return 1; }
    memset(heap_buf, 0x48, heap_sz);
    printf("heap : heap_buf (malloc) = %p\n", (void*)heap_buf);
}
\`\`\`

Переменная heap_buf указывает на адрес: 0xdbb2b0
Маппинг: 00dba000-00ddb000 rw-p 00000000 00:00 0                                  [heap]

Поскольку данных в самом бинарнике нет и быть не может, не привязана к inode (0).

В дампе памяти (оффсеты начиная с 0xdba000):

000012b0: 4848 4848 4848 4848 4848 4848 4848 4848  HHHHHHHHHHHHHHHH             

000012c0: 4848 4848 4848 4848 4848 4848 4848 4848  HHHHHHHHHHHHHHHH

000012d0: 4848 4848 4848 4848 4848 4848 4848 4848  HHHHHHHHHHHHHHHH

000012e0: 4848 4848 4848 4848 4848 4848 4848 4848  HHHHHHHHHHHHHHHH

... и так далее до 0x32a0 включительно


#### stack (стек)

Локальные переменные, адреса возврата, сохранённые регистры. Обычно растёт вниз (к меньшим адресам).

\`\`\`c
int main() {
    volatile int stack_int = 0x55667788;
    volatile uint8_t stack_buf[64];
    memset((void*)stack_buf, 0x5a, sizeof(stack_buf));
    printf("stack: &stack_int = %p\n", (void*)&stack_int);
    printf("stack: stack_buf = %p\n", (void*)stack_buf);
}
\`\`\`

Переменная stack_int имеет адрес: 0x7ffff87eb50c
Переменная stack_buf имеет адрес: 0x7ffff87eb4c0 (видим рост вниз)
Маппинг: 7ffff87cc000-7ffff87ed000 rw-p 00000000 00:00 0                          [stack]

В дампе памяти (оффсеты начиная с 0x7ffff87cc000):

0001f4c0: 5a5a 5a5a 5a5a 5a5a 5a5a 5a5a 5a5a 5a5a  ZZZZZZZZZZZZZZZZ

0001f4d0: 5a5a 5a5a 5a5a 5a5a 5a5a 5a5a 5a5a 5a5a  ZZZZZZZZZZZZZZZZ

0001f4e0: 5a5a 5a5a 5a5a 5a5a 5a5a 5a5a 5a5a 5a5a  ZZZZZZZZZZZZZZZZ

0001f4f0: 5a5a 5a5a 5a5a 5a5a 5a5a 5a5a 5a5a 5a5a  ZZZZZZZZZZZZZZZZ

0001f500: 0000 0000 0000 0000 0000 0000 8877 6655  .............wfU

#### mmap-области

Общие библиотеки (shared objects), memory-mapped файлы, анонимные отображения, иногда большие аллокации malloc. Могут быть R--, RW-, R-X в зависимости от назначения.

\`\`\`c
int main() {
    /* mmap (anonymous): отдельная mmap-область */
    size_t anon_sz = 0x3000;
    uint8_t *anon_map = (uint8_t*)mmap(NULL, anon_sz,
                                       PROT_READ | PROT_WRITE,
                                       MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
    if (anon_map == MAP_FAILED) { perror("mmap anon"); return 1; }
    memset(anon_map, 0x4d, anon_sz);

    /* mmap (file-backed): создаём временный файл и отображаем его */
    const char *path = "/tmp/mmap_demo.bin";
    int fd = open(path, O_CREAT | O_RDWR | O_TRUNC, 0600);
    if (fd < 0) { perror("open"); return 1; }
    size_t file_sz = 0x2000;
    if (ftruncate(fd, (off_t)file_sz) != 0) { perror("ftruncate"); return 1; }
     uint8_t *file_map = (uint8_t*)mmap(NULL, file_sz,
                                       PROT_READ | PROT_WRITE,
                                       MAP_SHARED, fd, 0);
    if (file_map == MAP_FAILED) { perror("mmap file"); return 1; }
    memset(file_map, 0x46, file_sz);
    memcpy(file_map, "FILE_MMAP_SIG", 12);
    printf("mmap: anon_map = %p\n", (void*)anon_map);
    printf("mmap: file_map (file-backed) = %p \n", (void*)file_map);
}
\`\`\`

Переменная anon_map имеет адрес: 0x7f17aae5e000
Переменная file_map имеет адрес: 0x7f17aac62000 

Маппинги: 

7f17aae5e000-7f17aae63000 rw-p 00000000 00:00 0

7f17aac62000-7f17aac64000 rw-s 00000000 08:30 2375503                    /tmp/mmap_demo.bin

Видимо отдельный inode у tmp-файла и метку shared в доступе (если переписать его, он перепишется у всех процессов).

В дампе памяти (оффсеты начиная с 7f17aae5e000):

00000000: 4d4d 4d4d 4d4d 4d4d 4d4d 4d4d 4d4d 4d4d  MMMMMMMMMMMMMMMM

00000010: 4d4d 4d4d 4d4d 4d4d 4d4d 4d4d 4d4d 4d4d  MMMMMMMMMMMMMMMM

00000020: 4d4d 4d4d 4d4d 4d4d 4d4d 4d4d 4d4d 4d4d  MMMMMMMMMMMMMMMM

00000030: 4d4d 4d4d 4d4d 4d4d 4d4d 4d4d 4d4d 4d4d  MMMMMMMMMMMMMMMM

и так до оффсета 0x3000.

#### vvar и vdso

Syscall - это дорого, поэтому в Linux есть vDSO (virtual Dynamic Shared Object) небольшая псевдо-библиотека, которую ядро подсовывает процессу как обычный ELF-модуль в памяти. В ней лежат быстрые реализации некоторых функций, которые иначе делались бы через syscall. vvar - это отдельная страница (или несколько страниц) памяти, где ядро держит данные, которые читает код vDSO.

Код на си:

\`\`\`c
int main() {
    printf("gettimeofday: %p\n", (void *)&gettimeofday);
    printf("time: %p\n", (void *)&time);
    return 0;
}
\`\`\`

Адрес gettimeofday: 0x7ffe24f68680
Адрес time: 0x7ffe24f68890

Не факт, что эти функции попадутся в vdso у вас:

Маппинги:
7ffe24f64000-7ffe24f68000 r--p 00000000 00:00 0                          [vvar]

7ffe24f68000-7ffe24f6a000 r-xp 00000000 00:00 0                          [vdso]

### Виртуальная память и страничная организация
#### Виртуальная память

Каждое обращение к адресу идёт в виртуальных координатах. MMU (блок управления памятью, memory management unit) переводит виртуальный адрес в физический через таблицы страниц. Для ускорения трансляции адресов виртуальной памяти в адреса физической используется кэш TLB (translation lookaside buffer). Эти устройства находятся в CPU. Если страницы нет в RAM или нет прав - возникает page fault.

MMU и TLB находятся на ядрах процессора. Как и кэш 1 уровня, они делятся на отдельный для инструкций и отдельный для данных + есть ещё общий вторичный + page-walk cache.

#### Страницы (paging)

Память делится на страницы фиксированного размера (обычно 4 Kб). Виртуальное адресное пространство процесса разбито на диапазоны (VMA), для которых заданы:

- права (R/W/X),
- тип (анонимная память, файл, shared),
- политика (copy-on-write, huge pages и т.д.)

Page fault (случай, когда отсутствует Page Table Entry для нужного адреса с нужным уровнем доступа) является нормальным явлением, так как может происходить по следующим причинам:

- Ленивая подгрузка (demand paging): код/данные подгружаются по мере обращения. После возникновения page fault ядро прочитает страницу с диска и повторит инструкцию.

- Copy-on-write (COW): после fork() страницы делятся между родительским и дочерним процессами. Как только кто-то начинает запись, ядро выделяет новую физическую страницу, копирует туда содержимое и даёт права на w тому, кто записывает. Аналогично для .data c MAP_PRIVATE.

- Zero-fill-on-demand для .bss и анонимной памяти:  .bss в ELF - NOBITS. Ядро не читает её из файла, а при первом доступе даёт нулевую страницу (или выделяет новую, заполненную нулями). Это тоже часто реализуется через page fault.

- Stack growth (рост стека): стек растёт по мере надобности. При обращении глубже текущей границы происходит page fault, ядро расширяет стек, мапит новую страницу и выполнение продолжается.
- Swap: редко используемые страницы могут выгружаться на диск. Если система решила выкинуть страницу из RAM, при повторном обращении придётся загрузить её из swap или перечитать с диска (если это файл/библиотека).
- mmap: чтение данных из mmap-файла почти всегда подтягивается страницами по требованию: page fault вызвает подгрузку нужной страницы файла.

Такие page faults - норма, но они дороже обычного доступа (переход в ядро, работа с диском). Различают два типа:

- minor fault: страница уже в RAM (всё, что не связано с походом в диск) — быстро;
- major fault: нужно читать с диска - существенно медленнее.

Ненормальные случаи page fault:
- доступ к несуществующему адресу - SIGSEGV
- запись в read-only область - SIGSEGV
- исполнение из страницы без прав на x - SIGSEGV
- out-of-memory при обработке fault - процесс может получить SIGKILL от OOM killer.

### Структура стека вызовов (call stack)

Стек - это структура для поддержки вложенных вызовов функций.

При вызове функции формируется кадр, где обычно есть:

- адрес возврата (куда продолжать после ret)

- сохранённые регистры

- локальные переменные функции

- временные данные (spill’ы регистров, выравнивание)

Упрощённая модель работы:

- call f кладёт адрес возврата на стек и переходит в f.

- Пролог функции выделяет место под локальные переменные, сохраняет нужные регистры.

- Эпилог восстанавливает регистры, освобождает место, ret снимает адрес возврата и прыгает назад.

Скомпилируем в ассемблер (gcc -S) следующую функцию на языке Си:

\`\`\`c
__attribute__((noinline))
int demo2(int a, int b, const char *s) {
    char buf[16];
    int x = a + b;

    memcpy(buf, s, 8);
    asm volatile("" : : "r"(buf) : "memory"); // чтобы buf точно считался живым

    return x + (unsigned char)buf[0];
}
\`\`\`

Рассмотрим ассемблерный код пролога этой функции

\`\`\`asm
    pushq	%rbp
	movq	%rsp, %rbp
\`\`\`
rsp на входе - return address. Push %rbp кладёт старый rbp на стек и уменьшает rsp на 8. rbp = rsp фиксирует базу кадра.saved RBP лежит по адресу [rbp+0], return address лежит по адресу [rbp+8].

Сохранение аргументов в стек (EDI - первый аргумент (32бит), ESI - второй аргумент (32 бит), RDX - третий аргумент (64 бит)). Соответственно, если бы третий тоже был 32 бит, он был бы EDX:

\`\`\`asm
movl %edi, -36(%rbp)   ; a
movl %esi, -40(%rbp)   ; b
movq %rdx, -48(%rbp)   ; s
\`\`\`

Код вычисления x = a+b:

\`\`\`asm
movl -36(%rbp), %edx
movl -40(%rbp), %eax
addl %edx, %eax
movl %eax, -4(%rbp)
\`\`\`
Забираем из регистров аргументы и складываем. x хранится по адресу [rbp-4] (int32).

Memcpy:
\`\`\`asm
movq -48(%rbp), %rax   ; rax = s
movq (%rax), %rax      ; rax = *(uint64_t*)s
movq %rax, -32(%rbp)   ; *(uint64_t*)&buf[0] = rax  (по сути)
\`\`\`
Компилятор понял, что мы копируем фиксированные 8 байт, и заменил memcpy(buf, s, 8) на прямую загрузку/запись 8 байт.

Формирование возвращаемого значения:
\`\`\`asm
leaq -32(%rbp), %rax   ; адрес buf
movzbl -32(%rbp), %eax ; eax = (unsigned char)buf[0]
movzbl %al, %edx
movl -4(%rbp), %eax    ; eax = x
addl %edx, %eax        ; eax = x + buf[0]
\`\`\`

Эпилог:
\`\`\`asm
popq %rbp
ret
\`\`\`

Итого имеем:

\`\`\`asm
[rbp+8]   return address
[rbp+0]   saved rbp

[rbp-4]   x (int)

[rbp-32]  buf[0..7]  (использованы первые 8 байт)
          (остальные байты buf[16] оптимизированы)
[rbp-36]  a (int spill)
[rbp-40]  b (int spill)
[rbp-48]  s (pointer spill)
\`\`\`

Теперь наглядно видно, как переполнением массива можно залезть в return address.

Глубокая рекурсия может привести к переполнению стека (stack overflow). Уязвимости типа stack buffer overflow возникают при выходе за границы локальных массивов.


Пролог/эпилог и расклад переменных зависят от оптимизаций и наличия указателя кадра (frame pointer) - регистра процессора (например, rbp в x86-64), используемого компиляторами для отслеживания текущего кадра стека при вызове подпрограмм (упрощает отладку, но занимает лишний регистр). 

## Фундаментальные механизмы защиты

### NX-bit (No-Execute)

Возникает логичный вопрос: если мы знаем, что код функций лежит в .text, а буфер в стеке / на куче, то почему бы нам не запретить выполнять код из стека / кучи / etc? В 1998 году энтузиасты выпустили [патч](https://www.openwall.com/linux/README.shtml), который запрещал исполнять код, лежащий на стеке. Однако, как известно, аппаратная защита в общем случае надёжнее программной. В 2003 году компания AMD вводит такое понятие как NX bit (No execute bit). Этим битом помечаются записи страниц (PTE), в которых не должно быть исполняемого кода. Он появляется в атлоне 64 и в серверном Opteron. В 2004 году Execute Disable добавляют в свои процессоры Intel, а точнее в 4 пеньки (начиная с Prescott). 14 августа 2004 года поддержка nx была добавлена в [Linux 2.6.8](https://kernelnewbies.org/Linux_2_6_8)

Попробуем исполнить код со стека. Для этого напишем следующую программу:

\`\`\`c
#include <stdio.h>
#include <stdint.h>

// функция, не принимает ничего и возвращает void
typedef int (*fn_t)(void);

int main(void) {
    unsigned char code[] = { 0xB8, 0x2A, 0x00, 0x00, 0x00, 0xC3 };
        /* x86 machine code
            mov eax(0xB8), 42 (0x00 0x00 0x00 0x2A)
            ret (0xC3)
            eax используется для возврата 32-битного целого значения.
        */
    fn_t f = (fn_t)(uintptr_t)code; // кастим массив байт к функции типа int f();
    int r = f(); // пытаемся исполнить
    printf("Executed OK, return=%d\n", r);
    getchar();
    return 0;
}
\`\`\`

Скомпилируем с помощью следующей команды:

\`\`\`bash
gcc -O0 -fno-stack-protector -fcf-protection=none -no-pie nx.c -o nx
\`\`\`
-fno-stack-protector -fcf-protection=none -no-pie отключают защиты, которые будут рассмотрены чуть позже

\`\`\`bash
[1]    36111 segmentation fault  ./nx
\`\`\`

Отлично. Это именно то, чего мы добивались. Убедимся, что segfault случился именно из-за попытки исполнить код. Введём команду dmesg и найдём там segfault:

\`\`\`bash
[ 1145.955670] nx[16902]: segfault at 7ffc7d7599ce ip 00007ffc7d7599ce sp 00007ffc7d7599b8 error 15
[ 1145.956231] Code: 00 00 00 00 08 9b 75 7d fc 7f 00 00 00 90 76 dc 45 7f 00 00 68 11 40 00 00 00 00 00 00 00 00 00 00 00 00 00 80 07 75 dc 45 7f <b8> 2a 00 00 00 c3 00 00 00 00 ce 99 75 7d fc 7f 00 00 01 00 00 00
[ 1145.956789] potentially unexpected fatal signal 11.
\`\`\`

Адрес segfault и instruction pointer совпадают, значит, ошибка действительно случилась при попытке выполнить код. Во второй строке как раз выделен b8, после которого идут 2a 00 00 00 c3. Это и есть то, что мы хотели выполнить. Сигнал 11 это и есть segfault. Error 15 [означает](https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/arch/x86/include/asm/trap_pf.h?h=v5.16#n5) MMU page-fault - мы уже перечисляли такой page-fault в списке "ненормальных" случаев.

Теперь скомпилируем тот же файл, но уже с отключенной защитой. Для этого добавим флаг: -z execstack: этот флаг помечает стек как исполняемый, теперь доступ к нему должен быть rwx. Запустим и получим следующий результат:

\`\`\`bash
./nx_execstack                             
Executed OK, return=42
\`\`\`

Теперь можно спокойно исполнять код со стека. Убедимся, что стек стал исполняемым, с помощью маппингов:

7ffe9df9b000-7ffe9dfbc000 rwxp 00000000 00:00 0                          [stack]

Действительно, в отличие от пункта, где мы разбирали организацию памяти в Linux, теперь у него доступ не rw-p, а rwxp

### ASLR (Address Space Layout Randomization)

Чтож, мы запретили выполнять случайный код, который нам пришлёт хакер. Это нас не спасёт от атаки, так как, скорее всего, у нас уже загружено много разных интересных библиотек, вызывая функции из которых можно натворить немало дел (вспомните SQL Slammer с его размером в одну UDP-датаграмму). Следовательно, следующий шаг - делать эти адреса каждый раз случайными, чтобы злоумышленнику было сложнее угадать. Для этого, 17 июня 2005 года, в [Linux 2.6.12](https://kernelnewbies.org/Linux_2_6_12) был добавлен механизм рандомизации адресного пространства. 

Всего есть три уровня рандомизации: 0 (отключен), 1 (консервативный, стек, VDSO, shared objects) и 2 (максимальный, по умолчанию, 1 + heap/brk). Узнать свой уровень можно с помощью команды:

\`\`\`bash
cat /proc/sys/kernel/randomize_va_space
\`\`\`

Убедимся, что механизм работает. Напишем небольшую программу, использующую стороннюю библиотеку:

\`\`\`c
#include <stdio.h>
#include "curl/curl.h"

int main() {
    printf("main:      %p\n", (void*)&main);
    printf("easy init: %p\n", (void*)&curl_easy_init);
    CURL *curl;
    CURLcode res;
    curl = curl_easy_init();
    if (curl) {
        curl_easy_setopt(curl, CURLOPT_URL, "http://example.com");
        curl_easy_setopt(curl, CURLOPT_FOLLOWLOCATION, 1L);
        res = curl_easy_perform(curl);
        if (res != CURLE_OK) {
            fprintf(stderr, "curl_easy_perform() failed: %s\n", curl_easy_strerror(res));
        }
        curl_easy_cleanup(curl);
    }
    getchar();
    return 0;
}
\`\`\`

\`\`\`bash
gcc -O0 -fno-stack-protector -fcf-protection=none -no-pie aslr.c -lcurl -o aslr
\`\`\`
Если не удаётся найти curl.h:
\`\`\`bash
apt update
apt install libcurl4-openssl-dev
\`\`\`

Результат запуска:
\`\`\`                                                                                                               main:      0x40129e
easy init: 0x7fc2dcb8a5d0
\`\`\`
Маппинги (самая интересная часть):
\`\`\`
01549000-015ab000 rw-p 00000000 00:00 0                                  [heap]
7fc2dcb68000-7fc2dcc0b000 r-xp 00015000 08:30 2422699                    /usr/lib/x86_64-linux-gnu/libcurl.so.4.8.0
7fc2dcc49000-7fc2dcc4a000 r--p 00000000 08:30 1468393                    /usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2
7ffd83142000-7ffd83163000 rw-p 00000000 00:00 0                          [stack]
7ffd831d6000-7ffd831da000 r--p 00000000 00:00 0                          [vvar]
7ffd831da000-7ffd831dc000 r-xp 00000000 00:00 0                          [vdso]
\`\`\`

Запустим программу ещё раз, чтобы убедиться, что адреса теперь другие:

\`\`\`                                                                                            
main:      0x40129e
easy init: 0x7f7523e995d0
7f7523e62000-7f7523e77000 r--p 00000000 08:30 2422699                    /usr/lib/x86_64-linux-gnu/libcurl.so.4.8.0
7f7523f58000-7f7523f59000 r--p 00000000 08:30 1468393                    /usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2
7fff39ad2000-7fff39af3000 rw-p 00000000 00:00 0                          [stack]
7fff39b58000-7fff39b5c000 r--p 00000000 00:00 0                          [vvar]
7fff39b5c000-7fff39b5e000 r-xp 00000000 00:00 0                          [vdso]
\`\`\`

Поменялись все адреса, кроме main. Почему не поменялся main разберём чуть далее.
### Stack Canaries

Очевидным вариантом является также запретить программе выходить за границы стека. В 1998 году был предложен патч к компилятору под названием [StackGuard](https://www.usenix.org/legacy/publications/library/proceedings/sec98/full_papers/cowan/cowan.pdf), который предлагал в конец стека каждой функции вставлять случайное значение (stack canary), а затем его проверять. Если происходило переполнение буфера, stack canary затиралась, после чего программа падала. Конечно, взломщик мог попробовать угадать это значение, но пришлось бы перебрать слишком много вариантов. В 2006 году в [gcc 4.1.0](https://gcc.gnu.org/gcc-4.1/changes.html) был добавлен флаг stack-protector, включающий такую защиту.

Напишем небольшую функцию на Си, чтобы проверить, так ли это. Canary достанем через ассемблер, так как её адрес известен: fs:0x28. При ошибке должна сработать __stack_chk_fail(void):

\`\`\`c
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h> 

#ifdef CANARYON
void __stack_chk_fail(void);
extern void __stack_chk_fail(void);

// Объявляем функцию ассемблера для прямого доступа к canary
#ifdef __x86_64__
unsigned long get_canary() {
    unsigned long canary;
    // В x86_64 canary обычно хранится в %fs:0x28
    __asm__ volatile (
        "mov %%fs:0x28, %0"
        : "=r" (canary)
        :
    );
    return canary;
}
#else
unsigned long get_canary() {
    return 0;
}
#endif
#endif

// Простая уязвимая функция
void vulnerable_function(char *input) {
    char buffer[16];  // Маленький буфер
    
    # ifdef CANARYON
    unsigned long canary = get_canary();
    printf("Значение canary: 0x%016lx\n", canary);
    printf("__stack_chk_fail: %p\n", __stack_chk_fail);
    # endif

    strcpy(buffer, input);  
}

int main(int argc, char *argv[]) {
    vulnerable_function(argv[1]);
    return 0;
}
\`\`\`

Компиляция и запуск:

\`\`\`
gcc canary_test.c -DCANARYON -fstack-protector-strong -o stack_canary_on  
./stack_canary_on $(python3 -c "print('A'*16)")
\`\`\`

Значение canary: 0x896a6fd929641400
Адрес __stack_chk_fail: 0x7fc6de006ba0

Дамп памяти (оффсеты начиная с 7ffd61aa8000):
\`\`\`
0001e890: 4141 4141 4141 4141 4141 4141 4141 4141  AAAAAAAAAAAAAAAA
0001e8a0: 0000 0000 0000 0000 0014 6429 d96f 6a89  ..........d).oj.
...
0001e960: 0200 0000 0000 0000 0014 6429 d96f 6a89  ..........d).oj.
\`\`\`
Действительно, после нашего буфера видна canary 896a6fd929641400. Она встречается неоднократно, что говорит о том, что canary одна на всю программу (если точнее, для user space - одна на поток).

Теперь попробуем передать что-то больше буфера.

\`\`\`
*** stack smashing detected ***: terminated
[1]    7500 IOT instruction  ./stack_canary_on $(python3 -c "print('A'*100)")
\`\`\`

Теперь скомпилируем без защиты:

\`\`\`
gcc canary_test.c -fno-stack-protector -o stack_canary_off  

./stack_canary_off $(python3 -c "print('A'*100)")
[1]    9760 segmentation fault  ./stack_canary_off $(python3 -c "print('A'*100)")
\`\`\`

Мы снова упали, но уже по другой причине: видимо, затёртые байты что-то там поломали

Установку canary можно также увидеть при разборке в ассемблере. Немного упростим программу:

\`\`\`
#include <stdio.h>
#include <string.h>
#include <stdlib.h>

void vulnerable_function(char *input) {
    char buffer[16]; 
    strcpy(buffer, input);  
}

int main(int argc, char *argv[]) {    
    vulnerable_function(argv[1]);
    
    return 0;
}
\`\`\`

Компиляция:

\`\`\`
gcc easy.c -fstack-protector-strong -S -o easy.s
gcc easy.c -fno-stack-protector -S -o easy_no.s
\`\`\`

diff для файлов ассемблера:

\`\`\`
diff easy.s easy_no.s                                                                                                  
13,19c13,16
<       subq    $48, %rsp
<       movq    %rdi, -40(%rbp)
<       movq    %fs:40, %rax
<       movq    %rax, -8(%rbp)
<       xorl    %eax, %eax
<       movq    -40(%rbp), %rdx
<       leaq    -32(%rbp), %rax
---
>       subq    $32, %rsp
>       movq    %rdi, -24(%rbp)
>       movq    -24(%rbp), %rdx
>       leaq    -16(%rbp), %rax
24,28d20
<       movq    -8(%rbp), %rax
<       subq    %fs:40, %rax
<       je      .L2
<       call    __stack_chk_fail@PLT
< .L2:
\`\`\`
Видим, что разница заключается как раз в работе с fs:40 (40(dec) = 28(hex)) и в вызове __stack_chk_fail если не сработал jumpequal.

### PIE (Position Independent Executable)

В примере с ASLR мы заметили, что почему-то не поменялся адрес main. Это всё из-за использования флага -no-pie. PIE собран так, чтобы мог запускаться по произвольному базовому адресу в виртуальном адресном пространстве процесса. Для динамических библиотек используется PIC (Position Independent Code), PIE используют для исполняемых файлов, он допускает некоторые оптимизации по сравнению с -fPIC (например, realtive-релокации, позже разберём что это). В shared library (PIC) многие обращения к глобальным символам вынужденно идут через GOT(Global Offset Table)/PLT(Procedure Linkage Table), потому что символ может быть подменён другой библиотекой через динамическую линковку.

Рассмотрим простую программу на Си:

\`\`\`
#include <stdio.h>

void sample() {
    printf("This is a sample function.\n");
}

int main() {
    printf("main: %p\n", (void *)&main);
    printf("sample: %p\n", (void *)&sample);

    getchar();
    return 0;
}
\`\`\`

Вывод и маппинги:
\`\`\`
main: 0x5638fca8d16f
sample: 0x5638fca8d159

5638fca8c000-5638fca8d000 r--p 00000000 08:30 2422665                    /root/noted-exps/pie/a.out
5638fca8d000-5638fca8e000 r-xp 00001000 08:30 2422665                    /root/noted-exps/pie/a.out
5638fca8e000-5638fca8f000 r--p 00002000 08:30 2422665                    /root/noted-exps/pie/a.out
5638fca8f000-5638fca90000 r--p 00002000 08:30 2422665                    /root/noted-exps/pie/a.out
5638fca90000-5638fca91000 rw-p 00003000 08:30 2422665                    /root/noted-exps/pie/a.out
\`\`\`

Перезапустим и убедимся, что адреса другие:

\`\`\`          
main: 0x55a846a7b16f
sample: 0x55a846a7b159          

55a846a7a000-55a846a7b000 r--p 00000000 08:30 2422665                    /root/noted-exps/pie/a.out
55a846a7b000-55a846a7c000 r-xp 00001000 08:30 2422665                    /root/noted-exps/pie/a.out
55a846a7c000-55a846a7d000 r--p 00002000 08:30 2422665                    /root/noted-exps/pie/a.out
55a846a7d000-55a846a7e000 r--p 00002000 08:30 2422665                    /root/noted-exps/pie/a.out
55a846a7e000-55a846a7f000 rw-p 00003000 08:30 2422665                    /root/noted-exps/pie/a.out
\`\`\`

## Продвинутые механизмы защиты
### Control Flow Integrity (CFI)

Допустим, злоумышленнику всё ещё удалось подменить цель перехода. Такого эффекта можно добиться с помощью code-reuse атак:

- Return-Oriented Programming (ROP)
- Jump-Oriented Programming (JOP)
- Call-Oriented Programming (COOP)

Как нетрудно догадаться по названиям, хакер в таком случае внедряет свои адреса для инструкций ret, jump и call. Поскольку правильные адреса известны заранее, можно построить список допустимых адресов, которые могут быть использованы в подобных инструкциях. Для защиты от этого существуют механизмы Control Flow Integrity (CFI). CFI бывает software-based (CFG/типы/подмножества целей) и hardware-assisted.

Основной алгоритм:

- На этапе компиляции/линковки строится модель допустимого потока управления: куда можно переходить из каждой точки программы. Это обычно делается в виде приближённого control-flow graph (CFG).

- В критические точки вставляются проверки: перед непрямыми переходами (call *reg, jmp *mem, вызовы через function pointer, vtable, PLT и т.п.) - проверка, что цель принадлежит разрешённому множеству, при возвратах из функций - проверка, что возвращаемся туда, откуда пришли.

Если проверка не проходит - trap/сигнал/abort (программа прекращает выполнение).

Forward-edge CFI защищает переходы к следующему коду:

- вызов через указатель на функцию;
- виртуальный вызов (C++ vtable);
- непрямой jmp/call.

Перед любой такой операцией он проверяет, что целевой адрес - один из допустимых.

Backward-edge CFI защищает возврат (ret). Адрес возврата берётся из стека, если атакующий его перезапишет - падаем. Обычно для этого используют shadow stack (software или hardware, например Intel CET SHSTK), либо подписи для адреса возврата. В GCC можно включить защиту ветвлений с помощью флага -fcf-protection=branch или -fcf-protection=full.

CFI не защищает от code-reuse полностью, так как атакующий всё ещё может подсунуть разрешённый переход. 

На процессорах Intel hardware часть CFI обеспечивается с помощью Control-flow Enforcement Technology (CET). Он впервые появился в 11 поколении, а linux kernel поддерживает с версии [5.18](https://kernelnewbies.org/Linux_5.18) от 22 мая 2022.

### Shadow Stack

Ещё одной частью Intel CET является идея shadow stack. Копия адреса возврата хранится отдельно от стека, чтобы потом была возможность их сравнить и убедиться, что никто её не переписал его значение. При вызове функции процессор кладёт адрес возврата и в обычный, и в shadow стек. При ret он их сравнивает: несовпадение - control-protection fault.

Рассмотрим следующую программу на Си:

\`\`\`c
#define _GNU_SOURCE
#include <stdio.h>
#include <stdint.h>
#include <stdlib.h>
#include <signal.h>
#include <string.h>

static void handler(int sig, siginfo_t *si, void *ctx) {
    (void)ctx;
    fprintf(stderr, "signal=%d (%s) si_code=%d", sig, strsignal(sig), si->si_code);
#ifdef SEGV_CPERR
    if (sig == SIGSEGV && si->si_code == SEGV_CPERR)
        fprintf(stderr, " [SEGV_CPERR: control-protection]");
#endif
    fputc('\n', stderr);
    _Exit(128 + sig);
}

__attribute__((noinline)) static void clobber_retaddr(void) {
    // Требуем frame pointer: return address лежит по [RBP+8]
    volatile uint64_t *rbp;
    asm volatile ("movq %%rbp, %0" : "=r"(rbp));
    volatile uint64_t *ret = (volatile uint64_t *)((char*)rbp + 8);
    *ret = 0x4141414141414141ULL; // намеренно "левый" адрес возврата
}

__attribute__((noinline)) static void victim(void) {
    clobber_retaddr();
    // возврат отсюда должен спровоцировать #CP при включённом SHSTK
}

int main(int argc, char **argv) {
    struct sigaction sa;
    memset(&sa, 0, sizeof(sa));
    sa.sa_sigaction = handler;
    sa.sa_flags = SA_SIGINFO;
    sigaction(SIGSEGV, &sa, NULL);
    sigaction(SIGILL,  &sa, NULL);
    sigaction(SIGBUS,  &sa, NULL);

    victim();

    puts("Успех!");
    return 0;
}
\`\`\`

Компилировать с флагами -O0 -fno-omit-frame-pointer -fno-stack-protector.

В GCC можно включить shadow stack с помощью флага -fcf-protection=return или -fcf-protection=full. Если у вас есть shadowstack, программа упадёт с segmentation fault с si_code=10(SEGV_CPERR) (код появился только 14 июля 2024 в [Linux 6.10](https://man7.org/linux/man-pages/man2/sigaction.2.html)). Сам shadow stack был добавлен в [Linux 6.6](https://www.phoronix.com/news/Linux-6.4-Shadow-Stack-Coming) 29 октября 2023.

### SafeStack

В LLVM/Clang пошли немного другим путём и предложили разделить стек на две части:

- safe stack: хранит то, что критично для управления и безопасно обращается - адреса возврата, spill’ы регистров, локальные переменные, которые компилятор считает безопасными.
- unsafe stack: хранит опасные объекты - в первую очередь те, адрес которых может утечь или которые могут быть перезаписаны переполнением.

Подразумевается, что переполнение буфера в unsafe части не сможет перезаписать return address, так как он лежит где-то в другом месте в памяти. Однако такая защита тоже не очень хорошая: если адрес безопасного стека утечёт, хакер сможет совершить свою атаку, поэтому лучше использовать SafeStack в связке с CFI. Ключ для включения в clang: -fsanitize=safe-stack. Он появился 8 марта 2016 года в [clang 3.8](https://releases.llvm.org/3.8.0/tools/clang/docs/SafeStack.html)

Важное ограничение: в [документации](https://clang.llvm.org/docs/SafeStack.html) сказано прямо: Linking a DSO with SafeStack is not currently supported.

## Защиты на уровне компилятора и компоновщика
### RELRO (Relocation Read-Only)

После того, как мы сделали PIE и PIC, нужно определить, как ориентироваться в памяти: ядро нарандомило адреса, теперь нужно записать оффсеты для конкретных функций. Для этого можно использовать релокации. Линковщик при сборке оставляет в ELF таблицы релокаций, где написано: по смещению X надо записать/прибавить/подставить значение, связанное с символом Y. При запуске динамический загрузчик читает эти записи и патчит память процесса.
GOT (Global Offset Table) - это таблица указателей/адресов, которую использует код, чтобы обращаться к глобальным переменным (особенно из других модулей) и функциям (в связке с PLT),
PLT (Procedure Linkage Table) - это набор маленьких stub’ов для вызова внешних функций. Допустим, мы хотим вызвать функцию puts. Компоновщик пишет следующее: puts@plt (PLT-стаб), который дальше использует GOT.PLT.

GOT.PLT - это область GOT, связанная с вызовами функций через PLT, особенно важная при lazy binding (ленивом связывании):
При первом вызове puts@plt:
- соответствующая GOT.PLT-ячейка ещё не содержит адрес puts.
- она содержит путь к резолверу динамического линкера.
- PLT-стаб прыгает по адресу из GOT.PLT → попадает в код ld.so, который находит реальный адрес puts в загруженных библиотеках, переписывает GOT.PLT-ячейку на реальный адрес puts и возвращает управление

При следующих вызовах puts@plt GOT.PLT уже содержит адрес puts, PLT-стаб сразу прыгает в puts, без участия ld.so.

Relocation Read-Only (RELRO) - механизм усиления защиты ELF-исполняемых файлов и shared-библиотек, который делает некоторые таблицы динамической линковки доступными только для чтения после того, как динамический загрузчик (ld.so) закончит начальную фазу релокаций.

Есть два типа RELRO:

- Partial RELRO (-z relro). Включает перевод в read-only для части структур после старта, но не для GOT.PLT из-за lazy binding
- Full RELRO (-z relro, -z now). Отключает lazy binding и делает все резолвы сразу, после чего GOT тоже делается read-only.

Возьмём следующую программу:

\`\`\`c
#include <stdio.h>
#include "curl/curl.h"

void sample() {
    printf("This is a sample function.\n");
}

int main() {
    printf("main: %p\n", (void *)&main);
    printf("sample: %p\n", (void *)&sample);
    printf("easy init: %p\n", (void*)&curl_easy_init);
    CURL *curl;
    CURLcode res;
    curl = curl_easy_init();
    if (curl) {
        curl_easy_setopt(curl, CURLOPT_URL, "http://example.com");
        curl_easy_setopt(curl, CURLOPT_FOLLOWLOCATION, 1L);
        res = curl_easy_perform(curl);
        if (res != CURLE_OK) {
            fprintf(stderr, "curl_easy_perform() failed: %s\n", curl_easy_strerror(res));
        }
        curl_easy_cleanup(curl);
    }
    getchar();
    return 0;
}
\`\`\`

Скомпилируем с RELRO Partial и Full:

\`\`\`
gcc relro.c -z relro -lcurl -o relro_part
gcc relro.c -z relro -z now -lcurl -o relro_full
\`\`\`

Посмотрим на секции got.plt с помощью readelf -S:

\`\`\`
readelf -S relro_part | grep got\.plt   
[24] .got.plt          PROGBITS         0000000000003fe8  00002fe8
       0000000000000058  0000000000000008  WA       0     0     8
readelf -S relro_full | grep got\.plt
\`\`\`

В relro_full .got.plt была слита линкером с .got. После запуска и назначения адресов он весь станет read-only.

Выведем .rela.dyn (общие динамические релокации) и .rela.plt(релокации слотов вызовов функций через PLT) с помощью readelf -r:

\`\`\`
Relocation section '.rela.dyn' at offset 0x6e8 contains 10 entries:
  Offset          Info           Type           Sym. Value    Sym. Name + Addend
000000003d68  000000000008 R_X86_64_RELATIVE                    11a0
000000003d70  000000000008 R_X86_64_RELATIVE                    1160
000000004008  000000000008 R_X86_64_RELATIVE                    4008
000000003fd0  000d00000006 R_X86_64_GLOB_DAT 0000000000000000 __cxa_finalize@GLIBC_2.2.5 + 0
000000003fd8  000200000006 R_X86_64_GLOB_DAT 0000000000000000 __libc_start_main@GLIBC_2.34 + 0
000000003fe0  000e00000006 R_X86_64_GLOB_DAT 0000000000000000 curl_easy_init@CURL_OPENSSL_4 + 0
000000003fe8  000a00000006 R_X86_64_GLOB_DAT 0000000000000000 _ITM_deregisterTM[...] + 0
000000003ff0  000b00000006 R_X86_64_GLOB_DAT 0000000000000000 __gmon_start__ + 0
000000003ff8  000c00000006 R_X86_64_GLOB_DAT 0000000000000000 _ITM_registerTMCl[...] + 0
000000004020  000f00000005 R_X86_64_COPY     0000000000004020 stderr@GLIBC_2.2.5 + 0

Relocation section '.rela.plt' at offset 0x7d8 contains 8 entries:
  Offset          Info           Type           Sym. Value    Sym. Name + Addend
000000003f90  000100000007 R_X86_64_JUMP_SLO 0000000000000000 printf@GLIBC_2.2.5 + 0
000000003f98  000300000007 R_X86_64_JUMP_SLO 0000000000000000 curl_easy_setopt@CURL_OPENSSL_4 + 0
000000003fa0  000400000007 R_X86_64_JUMP_SLO 0000000000000000 curl_easy_cleanup@CURL_OPENSSL_4 + 0
000000003fa8  000500000007 R_X86_64_JUMP_SLO 0000000000000000 curl_easy_perform@CURL_OPENSSL_4 + 0
000000003fb0  000600000007 R_X86_64_JUMP_SLO 0000000000000000 getchar@GLIBC_2.2.5 + 0
000000003fb8  000700000007 R_X86_64_JUMP_SLO 0000000000000000 fprintf@GLIBC_2.2.5 + 0
000000003fc0  000800000007 R_X86_64_JUMP_SLO 0000000000000000 curl_easy_strerror@CURL_OPENSSL_4 + 0
000000003fc8  000900000007 R_X86_64_JUMP_SLO 0000000000000000 puts@GLIBC_2.2.5 + 0
\`\`\`

Как это читать:

- R_X86_64_RELATIVE: по адресу X запиши base + addend (типично для PIE/ASLR, init/fini arrays и т. п.)

- R_X86_64_GLOB_DAT: по адресу X (обычно в GOT) запиши адрес символа S (например __libc_start_main, __cxa_finalize, curl_easy_init)

- R_X86_64_COPY: скопируй данные символа из shared-библиотеки в объект в .bss/.data главного бинарника
- R_X86_64_JUMP_SLOT: этот GOT/PLT-слот должен содержать адрес функции F
Каждая запись .rela.plt соответствует одной импортируемой функции

С помощью readelf -d можно прочитать адреса следующих полей:

\`\`\`
 0x0000000000000007 (RELA)               0x6e8 
 0x0000000000000008 (RELASZ)             240 (bytes)
 0x0000000000000017 (JMPREL)             0x7d8
 0x0000000000000003 (PLTGOT)             0x3f78
 0x0000000000000002 (PLTRELSZ)           192 (bytes)
\`\`\`

- RELA, RELASZ - где лежит .rela.dyn и её размер
- JMPREL, PLTRELSZ - где лежит .rela.plt и её размер
- PLTGOT - где лежат слоты GOT, используемые PLT

### Fortify Source

Fortify Source - механизм обёрток в libc, который добавляет проверки границ буфера для ряда опасных функций C (строковых и memory-функций) и тем самым помогает ловить переполнения на этапе компиляции и/или в рантайме.

При включённом _FORTIFY_SOURCE заголовки libc (обычно glibc) подменяют некоторые вызовы: strcpy, stpcpy, memcpy, memmove, memset, sprintf, snprintf, read, recv, и т. п. на варианты вида: __strcpy_chk, __memcpy_chk, __sprintf_chk.

Существует 3 уровня (кроме 0 - выключено):

1. проверки добавляются там, где размер буфера точно известен компилятору

2. охват функций/сценариев шире 

3. ещё более агрессивный режим в новых toolchain’ах (зависит от поддержки компилятором/заголовками libc)

При -O0 компилятор часто не может вывести размеры, и фортификация практически отключается, так что следует использовать оптимизацию -O1, а лучше -O2.

Скомпилируем следующую программу для уровня 1:

\`\`\`c
#include <string.h>
#include <stdio.h>

int main(void) {
    char dst[8];
    memcpy(dst, "012345622222222222789", 21);   // 21 > 8
    puts("done");
    puts(dst);
    return 0;
}
\`\`\`
\`\`\`
gcc -O2 -D_FORTIFY_SOURCE=1 -fno-stack-protector l1.c -o t1           

In file included from /usr/include/string.h:548,
                 from l1.c:1:
In function 'memcpy',
    inlined from 'main' at l1.c:6:5:
/usr/include/x86_64-linux-gnu/bits/string_fortified.h:29:10: warning: '__builtin___memcpy_chk' writing 21 bytes into a region of size 8 overflows the destination [-Wstringop-overflow=]
   29 |   return __builtin___memcpy_chk (__dest, __src, __len,
      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   30 |                                  __glibc_objsize0 (__dest));
\`\`\`

Действительно, появилась функция __builtin___memcpy_chk, которая вызывает при запуске:

\`\`\`
*** buffer overflow detected ***: terminated
[1]    73790 IOT instruction  ./t1
\`\`\`

Пример для второго уровня. Уровень 1 может считать размер всего объекта, а уровень 2 - более строгий, учитывает вложенный буфер:

\`\`\`c
#include <string.h>
#include <stdio.h>

struct S {
    struct T { char buf[5]; int x; } t;
    char buf[20];
};

int main(void) {
    struct S var = {0};
    strcpy(&var.t.buf[1], "abcdefg"); // 7 символов + '\0' => выходит за t.buf[5]
    puts(var.buf);
    return 0;
}
\`\`\`

\`\`\`gcc -O2 -D_FORTIFY_SOURCE=2 -fno-stack-protector l2.c -o t2                              
In file included from /usr/include/string.h:548,
                 from l2.c:1:
In function 'strcpy',
    inlined from 'main' at l2.c:11:5:
/usr/include/x86_64-linux-gnu/bits/string_fortified.h:81:10: warning: '__builtin___memcpy_chk' writing 8 bytes into a region of size 4 overflows the destination [-Wstringop-overflow=]
   81 |   return __builtin___strcpy_chk (__dest, __src, __glibc_objsize (__dest));
      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
\`\`\`

\`\`\`
./t2 
*** buffer overflow detected ***: terminated
[1]    76582 IOT instruction  ./t2
\`\`\`

Пример для третьего уровня. Уровень 3 использует __builtin_dynamic_object_size: может построить выражение, вычисляющее размер буфера в рантайме, и из-за этого вставить __memset_chk/__memcpy_chk даже там, где уровень 2 не знает размер:

\`\`\`c
#include <stdlib.h>
#include <string.h>
#include <stdio.h>

__attribute__((noinline))
static void escape(void *p) { asm volatile("" : : "r"(p) : "memory"); }

int main(int argc, char **argv) {
    size_t n = (argc > 1) ? strtoul(argv[1], 0, 0) : 16;

    char *p = (char*)malloc(n);
    if (!p) return 1;

    escape(p);                 // чуть мешаем компилятору упростить
    memset(p, 0, n + 1);       // overflow на 1 байт

    puts("проверки не сработали");
    free(p);
    return 0;
}
\`\`\`

\`\`\`
gcc -O2 -D_FORTIFY_SOURCE=3 -fno-stack-protector l3.c -o t3
./t3                              
*** buffer overflow detected ***: terminated
[1]    78965 IOT instruction  ./t3
\`\`\`

Никаких предупреждений нет, так как ловится в рантайме. Через readelf убедимся, что появился __memset_chk:

\`\`\`
readelf -sW t3 | grep mem                
     8: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND __memset_chk@GLIBC_2.3.4 (4)
    36: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND __memset_chk@GLIBC_2.3.4
\`\`\`
### Bounds Checking

В безопасных языках есть проверки на выход за границу. Например, в го при выходе за границы массива вы словите панику. В C/C++ всё немного сложнее. Обезопасить себя можно следующими способами:

Статический анализ:
- -Wall: включает стандартный набор наиболее полезных предупреждений компилятора.

- -Wextra: Дополняет -Wall дополнительными предупреждениями, которые часто выявляют ошибки/подозрительный код (например, лишние/неиспользуемые параметры, некоторые преобразования типов и т. п.).
- -Wstringop-overflow=2: предупреждает о переполнениях/выходах за границы в строковых операциях или операциях с памятью (memcpy/memmove/memset/strcpy/strcat/...), когда GCC может доказать или сильно подозревает, что запись выйдет за пределы. Значение =2 делает диагностику более строгой, чем уровень по умолчанию (могут быть ложные срабатывания).

- -Warray-bounds=2: предупреждает о выходе за границы массивов при индексировании, если компилятор может это вывести статически. Значение =2 делает диагностику более строгой, чем уровень по умолчанию (могут быть ложные срабатывания). Качество работы зависит от уровня оптимизации (при O0 могут вообще ничего не поймать)

- -Wformat-overflow=2: предупреждает, когда форматированный вывод (sprintf) потенциально пишет больше, чем размер целевого буфера.Значение =2 делает диагностику более строгой, чем уровень по умолчанию (могут быть ложные срабатывания).

- -Wformat-truncation=2: предупреждает, когда форматированный вывод через snprintf может обрезать результат, т. е. буфера может не хватить для полного вывода. Значение =2 делает диагностику более строгой, чем уровень по умолчанию (могут быть ложные срабатывания).

- -Wstringop-truncation: предупреждает о подозрительном обрезании в строковых операциях (например, когда копирование/конкатенация может привести к строке без '\0' или к неожиданно обрезанному результату, особенно вокруг strncpy, stpncpy и схожих паттернов).

- -Wvla: предупреждает о использовании VLA (variable length arrays: int a[n]; где n не константа). 

- -fanalyzer Включает статический анализатор GCC. Может находить: утечки памяти, возможные NULL-deref, use-after-free, двойной free, некоторые выходы за границы, непроверенные возвращаемые значения итд.

Рантайм анализ:
- -fsanitize=address: включает AddressSanitizer (ASan): вставляет рантайм-проверки, которые ловят выходы за границы (heap/stack/global), use-after-free, double free, heap-buffer-overflow, часть stack-buffer-overflow итд. При обнаружении ошибки обычно печатает отчёт со стек-трейсом и завершает процесс. (Бинарник становится тяжелее и медленнее; это режим для тестирования)

- -fno-omit-frame-pointer: запрещает компилятору выкидывать frame pointer (обычно регистр rbp на x86_64). Это делает стек-трейсы точнее и стабильнее для профайлеров, отладчиков и санитайзеров (в т. ч. ASan/UBSan), особенно при оптимизациях. 

- -D_FORTIFY_SOURCE=<уровень>, -fstack-protector-strong - рассматривались раньше

## Защиты ядра LINUX
### KASLR (Kernel Address Space Layout Randomization)

Тот же самый ASLR, только теперь для ядра Linux.

При загрузке системы загрузчик (например, GRUB) выбирает случайное смещение для базового адреса, по которому будет загружено ядро, и всех его критически важных регионов (например драйверов). Все абсолютные адреса внутри ядра пересчитываются с учетом этого смещения. Это происходит на каждом перезапуске системы, соответственно, при следующей загрузке смещение будет другим.

Атакующий, пытающийся эксплуатировать уязвимость (например, переполнение буфера), больше не может жестко закодировать адрес нужной ему функции (например, commit_creds() или system()). Ему придется угадывать, что статистически маловероятно.

Добавлен в [Linux 3.14](https://kernelnewbies.org/Linux_3.14#Kernel_address_space_randomization) 30 марта 2014 года.

### KPTI (Kernel Page Table Isolation)

Об уязвимостях процессоров Intel, предвещавших атаку Meltdown, было известно ещё в [2008 году](conference.hitb.org/hitbsecconf2008kl/index.html%3Fpage_id=214.html)

До исправлений многие x86_64 ОС держали почти всё ядро отображённым в таблицах страниц процесса даже в user-режиме (с запретом доступа через биты User/Supervisor), чтобы ускорить:

- переходы syscall/interrupt/exception
- обработку прерываний
- работу с kernel text/data, которые уже на месте по виртуальным адресам

Идея безопасна при условии, что CPU всегда строго проверяет привилегии. Уязвимость Meltdown, обнаруженная в 2017 году, ([CVE-2017-5754](https://nvd.nist.gov/vuln/detail/cve-2017-5754)) показал, что на уязвимых CPU это предположение неверно из-за поздней по отношению к фактической загрузке данных в микроархитектуру проверки:

- CPU начинает выполнять инструкции спекулятивно / вне очереди.
- Делает трансляцию адреса (страница существует, TLB/таблицы дают физический адрес).
- Транзиентно выполняет load из kernel-адреса, и значение попадает во внутренние буферы (например, line fill buffer) и может быть использовано следующими инструкциями до того, как исключение будет зафиксировано на стадии retirement.
- При нормальном завершении pipeline CPU понимает: доступ был незаконный - поднимает fault и откатывает архитектурное состояние. Но след в кэше остаётся (микроархитектурный эффект не откатывается полностью), и атакующий восстанавливает байт через timing (например, Flush+Reload).

KPTI (Kernel Page-Table Isolation) в Linux (ранее называлось KAISER) разделяет таблицы страниц user и kernel, чтобы в user-режиме почти всё ядро было не отображено вообще. Теперь это выглядит так: user CR3: user pages + минимальные трамплины/служебные маппинги для входа/выхода из ядра, kernel CR3: user pages + полноценные kernel mappings.

При переходе в ядро (syscall/interrupt) ядро переключает CR3 на kernel набор таблиц; при выходе - обратно на user. Это резко снижает поверхность атаки: Meltdown больше не может «достать» произвольные данные ядра через спекуляцию, потому что в user-режиме соответствующих PTE/маппингов нет (или они сведены к минимуму).

Проверить процессор на уязвимость к Meltdown и другим атакам можно, перейдя в каталог /sys/devices/system/cpu/vulnerabilities и прочитав все файлы.

\`\`\`
grep . /sys/devices/system/cpu/vulnerabilities/*

gather_data_sampling:Not affected
itlb_multihit:Not affected
l1tf:Not affected
mds:Not affected
meltdown:Not affected
mmio_stale_data:Unknown: No mitigations
retbleed:Mitigation: Enhanced IBRS
spec_rstack_overflow:Not affected
spec_store_bypass:Mitigation: Speculative Store Bypass disabled via prctl and seccomp
spectre_v1:Mitigation: usercopy/swapgs barriers and __user pointer sanitization
spectre_v2:Mitigation: Enhanced IBRS, IBPB: conditional, RSB filling, PBRSB-eIBRS: SW sequence
srbds:Not affected
tsx_async_abort:Not affected
\`\`\`

spectre_v1, spectre_v2 ([CVE-2017-5715](https://nvd.nist.gov/vuln/detail/cve-2017-5715) и [CVE-2017-5753](https://nvd.nist.gov/vuln/detail/cve-2017-5753)) тоже интересные атаки (нацелены на обман ветвления), но про них когда-нибудь потом (ещё retbleed тоже рядом, можно изучить, туда же MDS/L1TF).

KPTI появилась в [Linux 4.15](https://kernelnewbies.org/Linux_4.15) 28 января 2018 года.

### SMEP/SMAP (Supervisor Mode Execution/Access Prevention)

Продолжаем жёстко разделять user и kernel space. SMEP и SMAP - аппаратные механизмы защиты, реализованные в современных процессорах для предотвращения привилегированного выполнения или доступа к пользовательским данным из режима ядра.

SMEP (Supervisor Mode Execution Prevention) запрещает процессору, работающему в режиме ядра (супервизора, ring 0), исполнять код, который находится в страницах памяти, помеченных как принадлежащие пользовательскому пространству. При попытке это сделать возникает page fault. В PTE существует бит, определяющий уровень привилегий страницы: SUPERVISOR (0) или USER (1). Если процессор в ring 0 пытается перейти по адресу, находящемуся на странице с USER=1, срабатывает защита.

SMAP (Supervisor Mode Access Prevention) запрещает процессору, работающему в режиме ядра, ещё и читать и писать данные из страниц данных, помеченных как пользовательские. Когда SMAP включен, любая инструкция в режиме ядра, пытающаяся обратиться к данным в пользовательской странице, вызывает исключение. Для легитимных случаев, когда ядру надо обработать данные из пользовательского пространства (например, аргумент системного вызова copy_from_user()), существуют специальные инструкции, которые временно игнорируют SMAP: STAC (Set AC Flag) и CLAC (Clear AC Flag) — снова запрещает доступ. Эти инструкции оборачивают участки кода, где доступ необходим. SMAP появилась чуть позже SMEP, в процессорах Intel Broadwell (2014 год) и в [Linux 3.7](https://kernelnewbies.org/Linux_3.7) 10 декабря 2012 года (раньше появления на процессорах, так как она была анонсирована ещё в 2012 году, а вот появилась на реальных процессорах только в 2014).

## А зачем это знать Go-разработчику?

TL;DR: для общего развития. Go паникует при каждом выходе за границы (что всё ещё плохо, так как позволяет досить ваш сервис). Если вы не собираетесь пользоваться unsafe/cgo, вам стоит уделять внимание остальным проблемам: гонкам данных, дедлокам, инъекциям, криптографии, разделению ролей, ошибкам в логике и прочему. 

В этой статье раскрыта только самая база: на деле, конечно же, кроличья нора куда глубже. Если хотите укрепить свои знания и уже разобрали всё, что я упомянул, но не раскрыл, вот вам ещё куда смотреть:
- tcache/fastbin, use-after-free и double-free, атаки на malloc
- как ломать ASLR/KASLR, linux kernel infoleaks
- seccomp-bpf, Landlock, SELinux/AppArmor, namespaces/cgroups, capabilities, defense in depth.
- Kernel Self Protection Project
- eBPF
- Address/Undefined Behaviour/Thread/Memory санитайзеры
                        `
            const marked = new Marked(
								  markedHighlight({
									emptyLangClass: 'hljs',
									langPrefix: 'hljs language-',
									highlight(code, lang, info) {
									  const language = hljs.getLanguage(lang) ? lang : 'plaintext';
									  return hljs.highlight(code, { language }).value;
									}
								  })
								);
            const html = marked.parse(markdown);
            
            document.getElementById('html-output').innerHTML = html;
        }
	convertMarkdown()
    </script>
</body>
</html>          