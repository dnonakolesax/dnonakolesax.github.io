<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>VKAT V GO</title>
	<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.5.1/styles/github.min.css">
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 10px 0 10px 0;
        }
		img {
			width: 100%
		}
        #html-output {
            margin-bottom: 20px;
			margin-left: auto;
			margin-right: auto;
			width: 40vw;
			border: 1px solid gray;
			border-radius:12px;
			padding-left: 10px;
			padding-right: 10px;
        }
		
		@media (max-width: 768px) {
			#html-output {
				width: 90vw !important;
			}
		}
    </style>
</head>
<body>
    <div id="html-output"></div>
	<script src="https://cdn.jsdelivr.net/npm/marked/lib/marked.umd.js"></script>
	<script src="https://cdn.jsdelivr.net/npm/marked-highlight/lib/index.umd.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.5.1/highlight.min.js"></script>
    <script>
        function convertMarkdown() {
			const { Marked } = globalThis.marked;
			const { markedHighlight } = globalThis.markedHighlight;
            const markdown = `# 100 Ошибок в Go
           
### 1 - Затенение переменных

Рассмотрим следующий пример:

\`\`\`go
var client *http.Client 
if tracing { 
    client, err := createClientWithTracing() 
    if err != nil { 
        return err 
    } 
    log.Println(client)
} else { 
    client, err := createDefaultClient() 
    if err != nil { 
        return err 
    } 
    log.Println(client)
}
\`\`\`
Переменная client из первой строки затеняется в условных блоках, так как там объявляется локальная переменная client (через :=). Таким образом, объявленный в первой строке client так и останется nil
### 2 - Лишний вложенный код

Рассмотрим следующий пример:

\`\`\`go
if foo() {
    ...
    return true
} else {
    ...
}
\`\`\`

Здесь не нужен блок else, так как if возвращает true, следовательно, после него ничего не будет выполняться.
### 3 - Неправильное использование функции init()

Функция init() используется для инициации состояния приложения. Она не принимает аргументов и ничего не возвращает.
Когда модуль инициализируется, сначала выполняются все выражения типа var = и объявляются константы, затем запускается init()

Использование функции init() может привести к следующим проблемам:

- Ограниченность в обработке ошибок
- Усложнение тестирования модуля (например, при добавлении внешних зависимостей)
- Если для инициализации требуется находиться в каком-либо состоянии, это придётся сделать через глобальные переменные

Функции инициализации следует использовать с осторожностью. Они могут быть полезны в некоторых ситуациях, например, при задании статической конфигурации. В остальных случаях следует использовать ad-hoc функции
### 4 - Слишком частое использование getterов и setterов

Инкапсуляция данных позволяет спрятать значения, определяющие состояние объекта. Геттеры и сеттеры помогают реализовать инкапсуляцию, так как в них можно определить логику изменения объекта.

В Go нет встроенной поддержки геттеров и сеттеров, как в некоторых других языках. Нет смысла использовать их для доступа к полям структур. Не нужно использовать их там, где они не несут никакой ценности.

Go - простой язык, так что не нужно ничего усложнять. С другой стороны, если есть такая потребность, нет ничего плохого в том, чтобы использоваться /subj/
### 5 - Загрязнение интерфейсами

Интерфейсы - краеугольные камни разработки на Go. Вместе с тем, многие инструменты и парадигмы используют слишком много интерфейсов, что не является правильным. Загрязнение интерфейсами вносит в код лишние абстракции, из-за чего его становится труднее читать и понимать. Это распространённая ошибка среди тех, кто перешёл на Go с других языков.

Интерфейс является способом определить поведение объекта. Интерфейсы используются, чтобы создать множество объектов, которые будут реализовывать данный интерфейс. В Go используется duck typing, то есть не нужно в явном виде указывать, что структура имплементирует интерфейс - достаточно лишь реализовать в структуре те же методы, что и у интерфейса.

Рассмотрим библиотеку io, которая реализует стандартные интерфейсы для ввода и вывода. Например, io.Reader - абстракция для структуры, способной читать информацию, а io.Writer - для структуры, способной записывать информацию

У интерфейса io.Reader всего один метод:

\`\`\`go
type Reader interface {
    Read(p []byte) (n int, err error)
}
\`\`\`

Он должен читать информацию в слайс байт и возвращать количество прочитанных байт и информацию об ошибках

Аналогично с интерфейсом io.Writer:

\`\`\`go
type Writer interface {
    Write(p []byte) (n int, err error)
}
\`\`\`

Он должен записывать информацию из полученного слайса байт и возвращать количество записнных байт и информацию об ошибках

Таким образом, оба интерфейса обеспечивают две фундаментальные абстракции: чтение данных из источника и запись данных в цель

Зачем создавать два таких интерфейса? В чём цель таких абстракций? 

Представьте, что вам необходимо реализовать функцию, которая копирует данные из одного файла в другой. Такая функция может принимать на вход два указателя на os.File, либо мы можем создать более общую функцию, которая будет принимать io.Reader и io.Writer

\`\`\`go
func copySourceToDest(source io.Reader, dest io.Writer) error {
    // ...
}
\`\`\`

Таким образом, можно использовать данную функцию как для файлов (os.File реализует интерфейсы io.Reader и io.Writer), так и для любых других источиков данных. 

Кроме того, для такой функции удобнее писать юнит-тесты, так как вместо файла можно использовать пакеты strings и bytes:

\`\`\`go
func TestCopySourceToDest(t *testing.T) {
    const input = "foo"
    source := strings.NewReader(input) // Creates an io.Reader
    dest := bytes.NewBuffer(make([]byte, 0)) // Creates an io.Writer

    err := copySourceToDest(source, dest) // Calls copySourceToDest from a *strings.Reader and a *bytes.Buffer
    if err != nil {
        t.FailNow()
    }

    got := dest.String()
    if got != input {
        t.Errorf("expected: %s, got: %s", input, got)
    }
}
\`\`\`

В данном примере source - указатель на переменную типа strings.Reader, а dest - указатель на переменную типа bytes.Buffer. Таким образом, можно протестировать функцию copySourceToDest без создания файлов.

При проектировании интерфейсов также следует учитывать количество методов, содержащихся в интерфейсе.

> Чем больше интерфейс, тем слабее абстракция 
> (c) Роб Пайк, один из создателей Go.

К тому же, добавление методов в интерфейс уменьшает его переиспользуемость. io.Reader и io.Writer - мощные асбтракции, потому что их нельзя упростить. Если нам понадобится создать интерфейс, который будет объединять в себе функции чтения и записи, то мы сможем сделать следующее:

\`\`\`go
type ReaderWriter interface {
    Reader
    Writer
}
\`\`\`

Рассмотрим 3 основных случая использования интерфейсов в Go:

- Общее поведение
- Разъединение
- Ограничивающие поведение

#### Общее поведение

Рассмотрим применения из стандартной библиотеки:

- Поиск количества элементов в коллекции
- Функции сравнения для сортировки
- Перестановка двух элементов 

Таким образом, в библиотеку sort был добавлен следующий интерфейс:

\`\`\`go
type Interface interface {
    Len() int // Number of elements
    Less(i, j int) bool // Checks two elements
    Swap(i, j int) // Swaps two elements
}
\`\`\`

У этого интерфейса очень высокая степень переиспользования, так как он реализует стандартное поведения для сортировки любой коллекции, основанной на индексах 

В модуле sort можно найти множество имплементаций данного интерфейса. Если нам необходимо отсортировать коллекцию целых чисел, так ли важно нам, как это будет сделано? Будет ли использована быстрая сортировка или сортировка слиянием? В большинстве случаев - нет. Таким образом, поведение сортировки может быть абстрагировано и мы можем проставлять зависимости от интерфейса sort.Interface.

Выбор правильной абстракции также может принести много пользы. Например, модуль sort предоставляет некоторые вспомогательные функции, которые также используют sort.Interface. Например, функция проверки, отсортирована ли коллекция:

\`\`\`go
func IsSorted(data Interface) bool {
    n := data.Len()
    for i := n - 1; i > 0; i-- {
        if data.Less(i, i-1) {
            return false
        }
    }
    return true
\`\`\`

Так как sort.Interface находится на правильном уровне абстракции, он достаточно полезен.

#### Decoupling

Если мы полагаемся на абстракцию, а не на конкретную реализацию, то самую реализацию можно подменить, не внося больших изменений в код. Это принцип подстановки Лисков (Буква "L" в SOLID)

Кроме того, /subj/ упрощает тестирование. Рассмотрим следующую структуру, которая полагается на конкретную реализацию (mysql.Store, например)

\`\`\`go
type CustomerService struct {
    store mysql.Store // Зависит от конкретной реализации
}

func (cs CustomerService) CreateNewCustomer(id string) error {
    customer := Customer{id: id}
    return cs.store.StoreCustomer(customer)
}
\`\`\`

Как тестировать методы этой структуры? Так как структура зависит от mysql.Store, придётся проводить интеграционное тестирование, попутно создавая сущность типа mysql.Store (или использовать gosql-mock). Несмотря на то, что интеграционные тесты полезны, это не то, чего мы хотим добиться. Чтобы сделать код более универсальным, мы можем реализовать \subj\:

\`\`\`go
type customerStorer interface { // Creates a storage abstraction
    StoreCustomer(Customer) error
}

type CustomerService struct {
    storer customerStorer // Decouples CustomerService from the actual implementation
}

func (cs CustomerService) CreateNewCustomer(id string) error {
    customer := Customer{id: id}
    return cs.storer.StoreCustomer(customer)
}
\`\`\`

Поскольку хранение клиента теперь сделано через интерфейс, можно:

- Писать интеграционные тесты с помощью конкретной реализации
- Писать юнит-тесты с помощью моков для интерфейса CustomerService
- Всё сразу 

#### Ограничение поведения 

Предположим, что мы хотим создать модуль для динамической конфигурации приложения. Мы можем создать специфичный класс для целочисленных конфигураций с помощью структуры IntConfig, у которой имеется два метода: Get и Set:

\`\`\`go
type IntConfig struct {
    // ...
}

func (c *IntConfig) Get() int {
    // Retrieve configuration
}

func (c *IntConfig) Set(value int) {
    // Update configuration
}
\`\`\`

Предположим, что с помощью IntConfig мы передаём некоторый параметр (например, threshold), для которого должен быть доступен только метод Set(). Мы можем сделать это, реализовав следующий интерфейс:

\`\`\`go
type intConfigGetter interface {
    Get() int
}

type Foo struct {
    threshold intConfigGetter
}

func NewFoo(threshold intConfigGetter) Foo { // Injects the configuration getter
    return Foo{threshold: threshold}
}

func (f Foo) Bar()  {
    threshold := f.threshold.Get() // Reads the configuration
    // ...
}
\`\`\`

В этом примере мы инджектим configuration getter в Foo при создании. Он всё ещё может принимать IntConfig, так как она реализует интерфейсс intConfigGetter.

#### Загрязнение интерфейсами 

Часто в Go-проектах встречается загрязнение интерфейсами. Возможно, разработчики этих проектов перешли из C# или Java, где создание большого количества интерфейсов является естественным поведением. Но в Go всё работает по-другому

Интерфейсы нужны для создания абстракций, но при этом следует помнить, что абстракции следует открывать, а не создавать. Это означает, что не надо делать абстракции, если в этом нет потребности. Мы должны не проектировать интерфейсы, а ждать того момента, когда они понадобятся.

Добавление лишних интерфейсов усложняет читаемость кода. Если мы создаём интерфейс, но при этом непонятно, как это может сделать код лучше, следует использовать реализацию напрямую.

Примечание переводчика: интерфейсы не только усложняют читаемость, но и замедляют программу. Рассмотрим бенч и строение интерфейса...
//TODO

Давайте решать не абстрактные задачи, а те задачи, которые необходимо решать прямо сейчас!  
### 6 - Интерфейс на стороне производителя

Go использует вышеупомянутый duck typing, то есть не нужно явно указывать то, что структура имплементирует какой-либо интерфейс. Таким образом, интерфейсыы лучше объявлять на стороне потребителя, чтобы лишний раз не импортировать модули. Однако, в некоторых случаях, например, когда потребитель неизвестен, допускается объявление интерфейса на стороне производителя
### 7 - Возврат интерфейсов 

В большинстве случаев следует возвращать не интерфейс, а конкретную имплементацию. В другом случае это может усложнить код и увеличить количество зависимостей. С другой стороны, если вы ТОЧНО ЗНАЕТЕ (а не предвидите), что такая абстракция будет полезна для потребителя, используйте её.
### 8 - Any не говорит ни о чём

Any может быть полезен только если есть конкретная потребность в приёме ил ивозврате любого возможного типа (например, при маршалинге). В общем случае, следует избегать использования any любой ценой (даже если придётся чуть-чуть дублировать код)
### 9 - Не знать, когда следует использовать дженерики

Предположим, что у нас есть функция, которая получает все ключи из мапы с ключами типа string и значениями типа int

\`\`\`go
func getKeys(m map[string]int) []string {
    var keys []string
    for k := range m {
        keys = append(keys, k)
    }
    return keys
}
\`\`\`
Что будет, если мы захотим извлечь все ключи из мапы с ключами типа int и значениями типа string? Логика функции не поменяется, в отличие от принимаемых и возвращаемых значений. Неужели придётся копипастить функцию для каждого типа?

Можно пойти дальше и использовать any:

\`\`\`go
func getKeys(m any) ([]any, error) {
    switch t := m.(type) {
    default:
        return nil, fmt.Errorf("unknown type: %T", t)
    case map[string]int:
        var keys []any
        for k := range t {
            keys = append(keys, k)
        }
        return keys, nil
    case map[int]string:
        // Copy the extraction logic
    }
}
\`\`\`

Здесь мы можем заметить следующие проблемы

- Очередной boilerplate для проверки типа
- Функция нарушает строгую типизацию языка Go, кроме того, код замедлится от проверки на тип в рантайме
- Так как ключи бывают разных типов, приходится возвращать any, что может вынудить получателя также тратить время на приведение типов

К счастью, благодаря дженерикам, мы можем исправить положение:

\`\`\`go
func getKeys[K comparable, V any](m map[K]V) []K {
  var keys []K
  for k := range m {
    keys = append(keys, k)
  }
  return keys
}
\`\`\`

В силу внутренней реализации мапы в го, мы е можем использовать any для ключей, так как под капотом происходит их сравнение. Для этого следует использовать интерфейс comparable. 

Если мы хотим ограничить круг используемых типов, можно использовать constraint следующим образом:

\`\`\`go
type customConstraint interface {
   ~int | ~string // Define a custom type that will restrict types to int and string
}

// Change the type parameter K to be custom
func getKeys[K customConstraint, V any](m map[K]V) []K {
   // Same implementation
}
\`\`\`

Немного об операторе ~. Если бы мы написали просто int, то не смогли бы использовать производные от него операторы (например, те, которые являются алиасом для int):

\`\`\`go
type customConstraint interface {
   ~int
   String() string
}

type customInt int

func (i customInt) String() string {
   return strconv.Itoa(int(i))
}
\`\`\`
Кроме того, модуль constraints содержит обобщения, такие как Signed, которые объединяют все знаковые целочисленные типы.    

Дженерики нельзя использовать на методах, только на функциях. Следующий код не скомпилируется:

\`\`\`go
type Foo struct {}

func (Foo) bar[T any](t T) {}
\`\`\`

\`\`\`
./main.go:29:15: methods cannot have type parameters
\`\`\`

#### Использование и ошибки

Рекомендованные случаи для использования дженериков:

- Структуры данных: деревья, списки и прочие
- Функции, которые работают со слайсами, мапами и каналами любого типа. Например, функция, которая сливает два канала одинакового типа в один такого же типа может иметь следующую сигнатуру:

\`\`\`go
func merge[T any](ch1, ch2 <-chan T) <-chan T {
    // ...
}
\`\`\`

Вместо использования конкретного типа мы можем определить его поведение:

\`\`\`go
type sliceFn[T any] struct { // Use type parameter
   s       []T
   compare func(T, T) bool // Compare two T elements
}

func (s sliceFn[T]) Len() int           { return len(s.s) }
func (s sliceFn[T]) Less(i, j int) bool { return s.compare(s.s[i], s.s[j]) }
func (s sliceFn[T]) Swap(i, j int)      { s.s[i], s.s[j] = s.s[j], s.s[i] }
\`\`\`

Когда не следует использовать дженерики? 

- Когда вызывается метод конкретного типа. Например, если функция принимает io.Writer, не следует делать так:
\`\`\`go
func foo[T io.Writer](w T) {
   b := getBytes()
   _, _ = w.Write(b)
}
\`\`\`
- Когда они усложняют код. Дженерики не бесплатные, а разработчики Go прожили без них десять лет. Если введение дженериков никак не улучшает код в данный момент, не надо их использовать.
  

### 10 - Непонимание проблем вложенных типов

В Go можно заэмбедить тип напрямую, не добавляя поля данного типа. Однако, в некоторых случаях это может привести к неожиданным результатам. В Go структуру можно заэмбедить, если добавить её в другую структуру без имени переменной:

\`\`\`go
type Foo struct {
    Bar // Embedded field
}

type Bar struct {
    Baz int
}
\`\`\`

Для структуры Foo тип Bar будет являться embedded. Это означает, что мы можем получить доступ к значению Baz напрямую из Foo. 

Что можно сказать об эмбеддинге? Во-первых, очень редко возникает потребность в нём, то есть, большинство задач можно решить без эмбединга типов. Если вы решили его всё-таки использовать, помните две простые вещи:

- Не надо использовать его как синтаксический сахар для доступа к полям другой структуры (Foo.Bar вместо Foo.Baz.Bar)
- Он не должен нарушать инкапсуляцию, предоставляя другим функциям доступ к тем полям заэмбеженной структуры, которые должны быть скрыты от клиента.

### 11 - Неиспользование шаблона функциональных опций

Несмотря на разные реализации данного шаблона, есть два главных принципа:

- Неэкспортируемая структура содержит опции
- Каждая опция - это функция, которая имеет сигнатуру type Option func(options *options) error. Например:

\`\`\`go
type options struct {
  port *int
}

type Option func(options *options) error

func WithPort(port int) Option {
  return func(options *options) error {
    if port < 0 {
    return errors.New("port should be positive")
  }
  options.port = &port
  return nil
  }
}

func NewServer(addr string, opts ...Option) ( *http.Server, error) {
  var options options
  for _, opt := range opts {
    err := opt(&options)
    if err != nil {
      return nil, err
    }
  }

  // At this stage, the options struct is built and contains the config
  // Therefore, we can implement our logic related to port configuration
  var port int
  if options.port == nil {
    port = defaultHTTPPort
  } else {
      if *options.port == 0 {
      port = randomPort()
    } else {
      port = *options.port
    }
  }

  // ...
}
\`\`\`
Данный паттерн помогает предоставить дружелюбный для API способ задания конфигураций.
### 12 - Плохая организация проекта

Есть разные подходы к организации проекта. Можно использовать как разделение по контекстам(доменам), так и разделение по техническим слоям(репо, usecase, delivery).

Модули следует организовывать так, чтобы их названия были понятными, а количество импортов в программе было минимальным.

Есть разные подходы к организации проекта, однако, в общем и целом, все они вытекают из вышеописанных требований.
### 13 - Создание util модулей

Название модулей - важная часть проектирования приложения. Не нужно называть модули "common", "utils", "shared" и прочими, так как это не даёт никакого представления о том, что в этих модулях содержится
### 14 - Игнорирование коллизий в названиях модулей

Используйте уникальные названия для каждого модуля, чтобы не случалось коллизий, это повышает читаемость кода и спасёт вас от ситуаций, когда вы импортируете два одинаковых модуля и не можете их друг от друга отличить
### 15 - Отсутствие документации к коду

Документация к коду - важная часть разработки. Она определяет то, каким образом разработчики используют API, а также упрощает поддержку проекта.

Во-первых, каждый экспортируемый элемент(функция, интерфейс, структура, константа) должен иметь комментарии.

Во-вторых, каждый комментарий должен быть оконченным и осмысленным предложением, оканчивающимся точкой. Также надо помнить, что при комментировании функции следует уделить внимание тому, что она делает, а не как она это делает.

При комментировании переменной или константы, необходимо обратить внимания на два пункта: её назначение и содержимое

Чтобы помочь потребителям и разработчикам понять предназначение модуля, следует также прокомментировать и модуль.
### 16 - Неиспользование линтера

Линтер - статический анализатор кода, который помогает находить ошибки. Не стоит полагаться на указанные здесь линтеры, так как они могут довольно быстро потерять актуальность. Тем не менее, нужно понимать и помнить, зачем они нужны.

Тем не менее, если вы не пользуетесь линтерами, вот некоторые рекомендации:

- https://golang.org/cmd/vet—A Стандартный линтер го
- https://github.com/kisielk/errcheck—An Линтер ошибок
- https://github.com/fzipp/gocyclo—A Линтер с оценкой цикломатической сложности
- https://github.com/jgautheron/goconst—A Поиск повторяющихся констант

Кроме того, можно использовать средства для форматирования кода:

- https://golang.org/cmd/gofmt—A Стандартное средство форматирования Go кода
- https://godoc.org/golang.org/x/tools/cmd/goimports—A Удаляет лишние импорты

Кроме того, можно обратить внимание на https://github.com/golangci/golangci-lint. Этот линтер сочитает в себе многие остальные, кроме того, он может запускать проверки параллельно, что ускоряет работу.

Ещё один универсальный линтер: https://goreportcard.com/

### 17 - Путаница с восьмеричными литералами

Восьмеричные числа должны начинаться с нуля. Для повышения читаемости следует записывать восьмеричные числа с помощью 0o (Например, 8_10 = 0о10_8)

Аналогично для других оснований:

- Двоичные - префикс 0b или 0B (0b100 = 8)
- Шестнадцатиричные - префикс 0x или 0X (0xF = 15)
- Мнимые - суффикс i (3i)

Кроме того, для увеличения читаемости больших чисел можно использовать _ (например, миллион - 1_000_000)
### 18 - Переполнение целых чисел

В Go переполнение целого числа приведёт к ошибке компиляции, если, конечно, сможет увидеть его на этапе компиляции

\`\`\`go
var counter int32 = math.MaxInt32 + 1
\`\`\`
\`\`\`go
constant 2147483648 overflows int32
\`\`\`

Тем не менее, если переполнение произойдёт в рантайме, это не приведёт к панике. Вместо этого, вы можете столкнуться с непредвиденным поведением.
### 19 - Непонимание чисел с плавающей точкой

Если не считать комплексных чисел, в Go есть два типа чисел с плавающей точкой: float32 и float64. Нужно понимать, что значение чисел с плавающей точкой является лишь аппроксимацией реального значения

- [это](https://ru.wikipedia.org/wiki/%D0%A7%D0%B8%D1%81%D0%BB%D0%BE_%D1%81_%D0%BF%D0%BB%D0%B0%D0%B2%D0%B0%D1%8E%D1%89%D0%B5%D0%B9_%D0%B7%D0%B0%D0%BF%D1%8F%D1%82%D0%BE%D0%B9) надо знать
- [и это](https://ru.wikipedia.org/wiki/%D0%9C%D0%B0%D1%88%D0%B8%D0%BD%D0%BD%D1%8B%D0%B9_%D0%BD%D0%BE%D0%BB%D1%8C) тоже

\`\`\`go
var n float32 = 1.0001
fmt.Println(n * n)
\`\`\`
Мы ожидаем, что данный код выведет 1.00020001. Однако, большинство x86 процессоров вернут нам результат в 1.0002

Так как значения float32 и float64 являются аппроксимацией, нужно помнить о следующем:

-  При сравнении двух float следует использовать не строгое равенство, а проверять на то, меньше ли модуль разности некоторого EPS
- При выполнении сложения или вычитания группируйте операции похожего порядка для большей точности
- Первым делом выполняйте умножение и вычитание

Совет от автора: предположим, что вы работаете с температурой по цельсию. Вам необходимо рассчитывать среднее значение температуры за некоторый период с высокой точностью. Температура поступает с точностью в один знак. В этом случае предпочтительным способом являются хранить температуру в целом виде (для этого её придётся умножить на 10)

### 20 - Непонимание len и cap слайса

Под капотом Go слайс - всего лишь структура, состоящая из указателя на массив, количество элементов в слайсе (len) и размер массива(cap).

\`\`\`go
s := make([]int, 3, 6) // Слайс с len=3, cap=6
\`\`\`

Аргумент, отвечающий за размер массива(не слайса), является опциональным. Если его не указать, cap будет равен len/

Несмотря на то, что мест выделено под шесть элементов, при попытке обратиться к 4 элементу программа запаникует, так как размер слайса - 3 элемента.
Однако, если cap превышает len, мы можем использовать append без дополнительных аллокаций.

Если с помощью append добавить столько элементов, что общее количество будет превышать cap, программа выделит новый массив с другим cap и скопирует туда все элементы, а старый массив будет удалён сборщиком мусора (поскольку он является указателем, он размещён на куче).

Рассмотрим работу слайсинга. Имеется следующий код:

\`\`\`go
s1 := make([]int, 3, 6) // Three-length, six-capacity slice
s2 := s1[1:3] 
\`\`\`

S2 будет иметь len = 2 и cap = 5, так как при слайсинге включается начальный элемент (1 в данном случае) и не включается конечный элемент (3 в данном случае)   

Поскольку S2 ссылается на S1, при добавлении к нему какого-либо значения, это же значение добавится и к s1. Однако, если добавление значения к s2 приведёт к изменению cap s2, s1 и s2 будут ссылаться на разные массивы.

\`\`\`go
s2 = append(s2, 2)
print(s1)
print(s2)
s2 = append(s2, 3)
s2 = append(s2, 4) 
s2 = append(s2, 5)
print(s1)
print(s2)
\`\`\`

Поскольку у s1 всё ещё len=3, элементы, которые добавились в ходе append к s2, будут затёрты при append к s1
\`\`\`go
s1 = append(s1, 2)
print(s1)
\`\`\`

### 21 - Неэффективная инициализация слайса

При инициализации слайса с помощью make можно указать как len, так и cap для слайса. Если заранее известен конечный размер массива, указывайте его в cap, чтобы лишний раз не перевыделялась память и не вызывался сборщик мусора (который делает пусть и небольшой, но STW)
### 22 - Путать пустой и nil слайс

В Go есть разница между пустым и nil слайсом. Nil слайс == nil, а также имеет len=0 и cap=0. Каждый nil слайс пустой, но не каждый пустой слайс - nil. Создание nil слайса не вызывает никаких аллокаций. Есть несколько способов задания слайса:

- var s []string - Если нам неизвестна длина, а сам слайс может быть пустым
- []string(nil) - Синтаксический сахар для создания nil-слайса
- make([]string, length) - Если известна будущая длина массива

Последний вариант, []string{}, следует избегать, если инициализируется слайс без элементов. 
### 23 - Неправильная проверка слайса на пустоту

Чтобы определить, не пустой ли слайс, можно проверять его длину на равенство 0, а также проверять его на равенство nil. Предпочтительным является способ проверки длины на 0, так как он покрывает и пустые слайсы, и nil слайсы.

При проектировании интерфейсов следует избегать разделения пустых и nil слайсов. При возврате слайса и пустой слайс, и nil слайс должны означать одно и то же. Аналогично с мапами.
### 24 - Некорректное копирование слайсов

Копирование элементов из одного слайса в другой - частая операция. При использовании функции copy, мы должны учитывать, что количество скопированных элементов будет равняться длине меньшего из двух слайсов. Кроме того, помните про другие способы копирования слайса, так что не удивляетесь, когда увидите их в коде.
### 25 - Непредвиденные эффекты при использовании функции append

При использовании слайсинга нужно учитывать, что если длина результирующего слайса меньше, чем capacity того слайса, из которого он был сделан, append может модифицировать исходный слайс.
Вместо этого следует использовать copy или полноценную функцию слайсинга:

s[low:high:max] - создаёт слайс аналогично s[low:high], но cap будет равняться max-high
### 26 - Утечки памяти в слайсах

Помните, что слайсинг крупного слайса или массива может привести к утечке памяти, так как его cap может быть большим. Эта память не будет собрана сборщиком мусора, поэтому следует использовать copy.

При слайсинге слайса или массива указателей или структур с полями-указателями, сборщик мусора не очистит данные элементы. Следует либо использовать copy, либо вручную приравнивать все указатели к nil.
### 27 - Неэффективная инициализация мапы

//вкратце про мапу рассказать

Процесс роста мапы ещё сложнее, чем процесс роста массива, поэтому лучше сразу make с известным количеством.
### 28 - Утечки памяти в мапах

Предположим, что у нас имеется следующая мапа:

\`\`\`go
m := make(map[int][128]byte)
\`\`\`

Попробуйте создать пустую мапу, положить в неё 1_000_000 элементов, а затем удалить их. После удаления вручную вызовите сборщик мусора:

\`\`\`go
func main() {
    n := 1_000_000
    m := make(map[int][128]byte)
    printAlloc()

    for i := 0; i < n; i++ { // Adds 1 million elements
        m[i] = [128]byte{}
    }
    printAlloc()

    for i := 0; i < n; i++ { // Deletes 1 million elements
        delete(m, i)
    }

    runtime.GC() // Triggers a manual GC
    printAlloc()
    runtime.KeepAlive(m) // Keeps a reference to m so that the map isn’t collected
}

func printAlloc() {
    var m runtime.MemStats
    runtime.ReadMemStats(&m)
    fmt.Printf("%d MB\n", m.Alloc/(1024*1024))
}
\`\`\`

Можно увидеть следующие результаты:

\`\`\`go
0 MB   <-- After m is allocated
461 MB <-- After we add 1 million elements
293 MB <-- After we remove 1 million elements
\`\`\`

Дело в том, что мапа умеет увеличиваться, но не умеет уменьшаться, из-за чего все выделенные бакеты останутся даже при удалении всех элементов. Для небольшой оптимизации в данном случае можно хранить указатели, так как размер указателя меньше, чем размер массива из 128 байт, а всё, что стоит за указателем, соберёт сборщик мусора, так как оно выделено на куче:

\`\`\`go
map[int]*[128]byte
\`\`\`

\`\`\`go
0 MB   <-- After m is allocated
182 MB <-- After we add 1 million elements
38 MB <-- After we remove 1 million elements
\`\`\`

Если ключ или значение превышает 128 байт, Go будет хранить указатели на них
### 29 - Некорректное сравнение значений

Мы можем использовать операторы сравнения == и != для следующих типов:

- bool
- Numerics (int/float/complex)
- Strings
- Channels - nil=nil или созданы одним вызовом
- Interfaces - nil=nil или общая динамика 
- Struct and arrays - Сравнение собраны ли они из одинаковых типов

Для чисел и строк(лексиграфически) также можно использовать >= ? > <

Если типы не comparable, можно использовать reflect.DeepEqual (но это медленно)

Если важен перфоманс, можно попробовать использовать оптимизированный   bytes.Compare

### 30 - Игнорирование того, что в range элементы копируются

Range может итерироваться по следующим структурам данных:

- Строки
- Массивы
- Указатели на массивы
- Слайсы
- Мапы
- Принимающие каналы

Нужно помнить, что range копирует значение, так что при попытке изменить значение, мы изменим значение только у копии. Если нужно редактировать значение - используйте метку loop
### 31 - Игнорирование того, что элементы копируются только в самом начале цикла

Рассмотрим следующий код:

\`\`\`go
a := [3]int{0, 1, 2}
for i, v := range a {
    a[2] = 10
    if i == 2 {
        fmt.Println(v)
    }
}
\`\`\`
Мы ожидаем, что последний индекс будет равен 10, однако он равен двум, так как все значения масива a были скопированы перед самым первым прогоном цикла, так что его редактирование не повлияет на значения в range
### 32 - DEPRECATED IN GO1.22

Но помнить эту ошибку важно:

\`\`\`go
func (s *Store) storeCustomers(customers []Customer) {
    for _, customer := range customers {
        s.m[customer.ID] = &customer
    }
}
\`\`\`

По адресу customer всегда будет лежать текущее значение для итерации (т. е. по окончании цикла - последний). Следовательно, вся мапа будет заполнена последними элементами.
### 33 - Ложные ожидания от порядков элемента в мапе при итерации

При итерировании по мапе помните, что:

- Мапа не упорядочена по значению ключей (fmt.Println сам сортирует её на этапе вывода)
- Мапа не упорядочена по порядку вставки ключей
- Порядок обхода случайный
- Если при итерировании по мапе вы вставите в неё значении, вы можете на него наткнуться в рамках того же for range (а можете и не наткнуться)
### 34 - Непонимание того, как работает break

Рассмотрим следующий код:
\`\`\`go
for i := 0; i < 5; i++ {
    fmt.Printf("%d ", i)

    switch i {
    default:
    case 2:
        break
    }
}
\`\`\`
В данном коде break будет означать выход из switch, но не из for! Если вы хотите, чтобы он выходил из for, используйте Loop и метки:

\`\`\`go
    for i := 0; i < 5; i++ {
        fmt.Printf("%d ", i)

        switch i {
        default:
        case 2:
            break loop
        }
    }
\`\`\`
### 35 - Использование defer в цикле

Отложенный вызов(defer) используется для уменьшения boilerplate. Рассмотрим следующий пример

\`\`\`go
func readFiles(ch <-chan string) error {
    for path := range ch {
        file, err := os.Open(path)
        if err != nil {
            return err
        }

        defer file.Close()

        // Do something with file
    }
    return nil
}
\`\`\`
Ожидается, что defer будет использоваться в конце каждой итерации. Однако, на практике он будет вызван только при выходе из функции readFiles, что может привести к бесконечно открытомым файловому дескрипторам и утечке. Предлагается следующее решение проблемы:

\`\`\`go
func readFiles(ch <-chan string) error {
    for path := range ch {
        if err := readFile(path); err != nil {
            return err
        }
    }
    return nil
}

func readFile(path string) error {
    file, err := os.Open(path)
    if err != nil {
        return err
    }

    defer file.Close()

    // Do something with file
    return nil
}
\`\`\`


### 36 - Непонимание концепта рун

- Набор символов имеет кодировку, которая описывает способ перевода данного набора символов в двоичное представление
- В Go строка - неизменяемый слайс байт (int8)
- Go использует UTF-8. Однако, если стройка приходит из внешнего источника, никто не гарантирует, что она будет в кодировке UTF-8
- Руна представляет собой концепцию Unicode code point
- Руна занимает от 1 до 4 байт (помните, что, поскольку русские буквы не входят в ASCII, они будут гарантированно занимать больше одного байта)
- len() строки возвращает количество БАЙТ, а НЕ РУН
### 37 - Неправильная итерация по строкам

Рассмотрим следующий код:

\`\`\`go
s := "привет"
for i := range s {
    fmt.Printf("position %d: %c\n", i, s[i])
}
fmt.Printf("len=%d\n", len(s))
\`\`\`

\`\`\`
position 0: Ð
position 2: Ñ
position 4: Ð
position 6: Ð
position 8: Ð
position 10: Ñ
len=12
\`\`\`

СМОТРИТЕ ПРЕДЫДУЩУЮ ОШИБКУ

Чтобы правильно итерироваться, следующий код:

\`\`\`go
s := "hêllo"
for i, r := range s {
    fmt.Printf("position %d: %c\n", i, r)
}
\`\`\`
Либо можно конвертировать строку в слайс рун, однако этот процесс будет иметь сложность O(n), где n - длина строки. Зато такая конвертация позволяет получить доступ к руне по индексу.

\`\`\`go
s := "привет"
runes := []rune(s)
fmt.Printf("%c\n", runes[4])
for i, r := range runes {
    fmt.Printf("position %d: %c\n", i, r)
}
\`\`\`

### 38 Неправильное использование функции trim

Рассмотрим следующий пример:
\`\`\`go
fmt.Println(strings.TrimRight("123oxo", "xo"))
\`\`\`

Он выведет 123, так как strings.TrimRight будет удалять из суффикса все элементы, перечисленные в "xo". Аналогично будет с strings.TrimLeft.

Если нужно отрезать конкретный суффикс или префикс, используйте strings.TrimSuffix / strings.TrimPrefix
### 39 - Неоптимизированное слияние строк

Напишем функцию, которая сливает слайс строк в одну строку

\`\`\`go
func concat(values []string) string {
    s := ""
    for _, value := range values {
        s += value
    }
    return s
}
\`\`\`
Поскольку строка - объект неизменяемый, каждый += вызывает дополнительную аллокацию в памяти.

К счастью, для решения данной проблемы можно использовать strings.Builder:

\`\`\`go
func concat(values []string) string {
    sb := strings.Builder{}
    for _, value := range values {
        _, _ = sb.WriteString(value)
    }
    return sb.String()
}
\`\`\`

Под капотом WriteString использует слайс байт, поэтому его также следует проинициализировать сразу нужного размера, чтобы избежать лишних аллокаций и проходов GC:

\`\`\`go
func concat(values []string) string {
    total := 0
    for i := 0; i < len(values); i++ {
        total += len(values[i])
    }

    sb := strings.Builder{}
    sb.Grow(total) (2)
    for _, value := range values {
        _, _ = sb.WriteString(value)
    }
    return sb.String()
}
\`\`\`
### 40 - Бесполезные преобразования строк

Большинство пакетов для ввода и вывода работают не со строками, а со слайсами байт. Если вам приходится работать с ними, старайтесь без надобности не конвертировать слайсы байт в строки. Вместо этого ознакомьтесь с пакетом bytes и его функциями: Split, Count, Contains, Index и так далее.
### 41 - Утечки памяти при работе со строками

В ошибке 26 были рассмотрены типичные ошибки при копировании слайсов. Поскольку строка - алиас для слайса байт, аналогичные правила работают и для строк. Помните, что размер строки указывается в байтах, а не в рунах, а операция substring может приводить к утечке памяти, если подстрока ссылается на исходную строку. Лучше копировать строки руками или использовать strings.Clone.

### 42 - Типы ресиверов

Ресивер метода структуры может быть указателем или значением

Выбирайте указатель, если:

- Метод редактирует структуру-ресивер
- Метод-ресивер содержит типы данных, которые нельзя копировать (например, из пакета sync)

Если ресивер - большой объект, также предпочтительно использовать указатель

Выбирайте значение, если:

- Нужно обеспечить иммутабельность ресивера
- Ресивер - мапа, функция (да, так тоже можно) или канал.


### 43 - 44 - Именнованные параметры возврата

В go можно делать так:
\`\`\`go
func f(a int) (b int) {
    b = a
    return
}
\`\`\`

Типичная ошибка при работе с именованными параметрами   :

\`\`\`go
func (l loc) getCoordinates(ctx context.Context, address string) (
    lat, lng float32, err error) {
    isValid := l.validateAddress(address) (1)
    if !isValid {
        return 0, 0, errors.New("invalid address")
    }

    if ctx.Err() != nil { (2)
        return 0, 0, err
    }

    // Get and return coordinates
}
\`\`\`
err возвращается, но значение ему не присвоено.
### 45 - возврат nil

Рассмотрим данный код:

\`\`\`go
func (c Customer) Validate() error { 
    var m *MultiError //Создается пустой *MultiError 
    if c.Age < 0 { 
        m = &MultiError{} 
        m.Add(errors.New("age is negative")) 
    } 
    if c.Name == "" { 
        if m == nil { 
            m = &MultiError{} 
        } 
        m.Add(errors.New("name is nil")) 
    }
    return m
}
\`\`\`

Что будет, если данная функция отработает без ошибок? Мы ожидаем, что err будет равен nil, и после вызова функции условие err != nil будет ложно. Однако, мы создали ошибку кастомного типа, а возвращаем интерфейс ошибки. Это приводит к тому, что сама m будет nil, а вот возвращённая ошибка - уже нет. Чтобы избежать этого, необходимо добавить проверку на nil внутри самой функции. То есть интерфейс error, который является обёрткой, не будет nil, а m - будет.
### 46 - Имя файла в качестве ввода для функции

Не надо так делать, используйте универсалньые io.Reader и io.Writer
### 47 - Аргументы для defer

Рассмотрим данный код:

\`\`\`go
func f() error { 
    var status string 
    defer notify(&status) 
    defer incrementCounter(&status)
    if err := foo(); err != nil { 
        status = StatusErrorFoo 
        return err 
    } 
    if err := bar(); err != nil { 
        status = StatusErrorBar 
        return err 
    } 
    status = StatusSuccess 
    return nil
    }
\`\`\`

Здесь в качестве аргумента к defer передаётся не просто статус, а ссылка на него. Это сделано по той причине, что аргументы defer вычисляются в момент создания отложенного вызова, а не начала его выполнения. Если передать статус по значению, он всегда будет пустой строкой, независимо от результатов работы

Другой способ: воспользоваться замыканием

\`\`\`go
func f() error { 
    var status string 
    defer func() { 
        notify(status) 
        incrementCounter(status) 
    }() // Далее код функции остается неизменным
}
\`\`\`

Аналогично для вызова методов структур:

\`\`\`go
func main() { 
    s := &Struct{id: "foo"} 
    defer s.print() 
    s.id = "bar" //Обновление s.id (видимое)
}
type Struct struct { 
    id string
}
func (s *Struct) print() { 
    fmt.Println(s.id)
}
\`\`\`
Если бы s был не ссылкой, программа вывела бы "foo"

### 48 - Паника

Паника - это не то же самое, что throw error в других языках, поэтому её не должно случаться в рантайме, только на этапах инициализации. Для остальных случаев возвращайте error
### 49 - Обёртки ошибок

Не забывайте оборачивать ошибки с помощью %w, чтобы добавлять контекст.

\`\`\`go
if err != nil {
    return fmt.Errorf("foo failed: %w", err)
}
\`\`\`
Либо, для большей гибкости, можно создать свою структуру, реализующую интерфейс ошибки (для этого нужно реализовать метод Error() string)

### 50-51 - Проверка ошибки

Для проверки кастомных типов ошибки используйте Errors.As()
Для проверки кастомных значений ошибки используйте Errors.Is()


### 52 - Двойная обработка ошибки

Не надо обрабатывать ошибки по два раза. Если ошибка уже обработана раннее - просто прокидывайте дальше

\`\`\`go
func GetRoute(srcLat, srcLng, dstLat, dstLng float32) (Route, error) {
    err := validateCoordinates(srcLat, srcLng)
    if err != nil {
        return Route{}, fmt.Errorf("failed to validate source coordinates: %w", err)
    }
    err = validateCoordinates(dstLat, dstLng)
    if err != nil {
        return Route{}, fmt.Errorf("failed to validate target coordinates: %w", err)
    }
    return getRoute(srcLat, srcLng, dstLat, dstLng)
}

func validateCoordinates(lat, lng float32) error {
    if lat > 90.0 || lat < -90.0 {
        return fmt.Errorf("invalid latitude: %f", lat)   //Только возврат ошибки
    }
    if lng > 180.0 || lng < -180.0 {
        return fmt.Errorf("invalid longitude: %f", lng)   //Только возврат ошибки
    }
    return nil
}
\`\`\`

Здесь предполагается, что ошибку обработает тот, кто вызвал GetRoute.
### 53-54 Необработка ошибок

Не забывайте обрабатывать ошибки
Если вдруг возникла потребность в необработке, проигнорируйте ошибку с помощью символа "_", чтобы остальные видели, что ошибка проигнорирована намеренно

Учтите, что всё, что вы вызвали в defer, тоже может вернуть ошибку, и это тоже нужно обрабатывать

### 55 - Конкурентность и параллелизм

Параллелизм - решение независимых задач с помощью нескольких процессов / потоков / горутин...
Конкурентность - параллелизм, но у задач есть общий ресурс, за который они конкурируют (например, редактируют одну и ту же мапу)
### 56 - Конкурентность не всегда быстрее

Иногда конкурентность приводит лишь к нагромождениям из блокировок, что усложняет процесс разработки, но не увеличивает скорость работы, так как из-за постоянных блокировок программа работает как будто в однопоточном режиме. К тому же, не следует забывать о накладных расходах на синхронизацию, шедулер, порождение новых горутин итд
### 57 - Каналы и мьютексы

Не знаю, как их можно перепутать, больше похоже на пункт-филлер, чтобы добить до сотни

Канал - механизм для коммуникации (пересылки значений) между горутинами
Мьютекс - механизм для синхронизации (запрета на параллельное выполнение некоторой части кода, в основном той, где возникает доступ к одному и тому же значению) между горутинами.
### 58 - Проблемы гонки данных

Если 2 или больше горутин получают доступ к одному и тому же значению и хотя бы одна из них его записывает - конечный результат непредсказуем (data race). 

Чтобы этого избежать, используйте атомики / мьютексы / каналы для синхронизации.

Если в коде нет data race, не значито, что нет race condition (состояние, когда поведение некоторого блока программы невозможно предсказать, например, из-за невозможности предсказать последовательность выполнения горутин)
### 59 - виды нагрузок

На скорость работы приложения влияют следующие виды нагрузок:

- CPU-bound. Длительная нагрузка на процессор: сортировки, поиски, обходы графов и прочее
- I/O-bound. Ожидание ответа от базы, другого сервиса и прочее
- Memory-bound. Загрузка оперативки кучей данных. Неактуально, так как оперативка сейчас дёшевая (а ещё изобрели своппинг)

Если вы работаете с CPU-bound, нет смысла порождать больше горутин, чем runtime.GOMAXPROCS, так как все они будут заняты очень долго, и по сути программа скатывается к обычной многопоточке
Если вы работаете с I/O-bound, имеет смысл делать гораздо больше горутин, так как они быстро будут переключаться в рамках одного системного потока
### 60 - Контексты

Не забывайте использовать контексты для:

- Установки дедлайна
- Передачи сигнала отмены
- Передачи значений в формате key - value


### 61 - Ошибки при работе с контекстами

С контекстами нужно быть аккуратнее. Предположим, есть следующий код:

\`\`\`go
func handler(w http.ResponseWriter, r *http.Request) {
    response, err := doSomeTask(r.Context(), r)
    if err != nil {
        http.Error(w, err.Error(), http.StatusInternalServerError)
    return
    }
    go func() {
        err := publish(r.Context(), response)
        // Do something with err
    }()
    writeResponse(response)
}
\`\`\`

Контекст r.context() отменится, как только будет записан результат. Однако, мы уже запустили publish, конца которого не дожидаемся (допустим, в кафку). Таким образом, если ответ будет записан раньше, чем случится publish, в кафку ничего не уйдёт из-за отмены контекста. В Go 1.21 добавили context.WithoutCancel, который не отменяется при отмене родительского.


### 62 - Отмена горутины 

Рассмотрим вот такого вот сферического коня в вакууме:
\`\`\`go
func main() {
    newWatcher()
    // Run the application
}

type watcher struct { /* Some resources */ }

func newWatcher() {
    w := watcher{}
    go w.watch() // Creates a goroutine that watches some external configuration
}
\`\`\`

Горутина w.watch() не имеет механизма отмена, а значит, по окончании работы программы, она не будет правильно освобождена.

Допустим, мы используем отмену контекста для решения этой проблемы

\`\`\`go
func main() {
    ctx, cancel := context.WithCancel(context.Background())
    defer cancel()
    newWatcher(ctx)
    // Run the application
}

func newWatcher(ctx context.Context) {
    w := watcher{}
    go w.watch(ctx)
}
\`\`\`

Всё ещё нет никаких гарантий, что после получения сигнаала об отмене watch успеет освободить все свои ресурсы.

В таком случае лучше сделать следующим образом:

\`\`\`go
func main() {
    w := newWatcher()
    defer w.close()
    // Run the application
}

func newWatcher() watcher {
    w := watcher{}
    go w.watch()
    return w
}

func (w watcher) close() {
    // Close the resources
}
\`\`\`

Теперь, благодаря defer в main, мы можем быть уверены, что все ресурсы будут освобождены.
### 63 - DEPRECATED

https://go.dev/blog/loopvar-preview

Аналогично deprecated пункту 32:

\`\`\`go
func main() {
    done := make(chan bool)

    values := []string{"a", "b", "c"}
    for _, v := range values {
        go func() {
            fmt.Println(v)
            done <- true
        }()
    }

    // wait for all goroutines to complete before exiting
    for _ = range values {
        <-done
    }
}
\`\`\`
Вместо ожидаемых a,b,c замыкание выведет c,c,c
### 64 - Недетерменированный select

Рассмотрим следующий селект

\`\`\`go
go func() {
  for i := 0; i < 10; i++ {
      messageCh <- i
    }
    disconnectCh <- struct{}{}
}()

for {
    select {
    case v := <-messageCh:
        fmt.Println(v)
    case <-disconnectCh:
        fmt.Println("disconnection, return")
        return
    }
}
\`\`\`

Сколько цифр успеет напечататься прежде, чем программа выключится? Хочется думать, что все 10. На самом деле это число случайно. Разработчики нам по этому поводу говорят следующее:

>If one or more of the communications can proceed, a single one that can proceed is chosen via a uniform pseudo-random selection.

Т. е. если в обоих каналах есть данные, go случайно выберет, из какого прочитать на текущем этапе. В отличие от switch, здесь нет такого правила, что чем выше стоит условие, тем больше у него приоритет.
### 65 - Каналы для уведомлений

Предположим, что имеется канал, который должен нас уведомлять о наступлении некоторого события. Первым делом хочется сделать такой канал небуферизированным с типом bool:

\`\`\`go
disconnectCh := make(chan bool)
\`\`\`
При таком подходе есть следующие вопросы:

- Что отправлять: true или false?
- Что делать, если выбрали одно, а пришло другое?

Чтобы не задумываться над этим, предлагается использовать канал с пустой структурой:
\`\`\`go
disconnectCh := make(chan struct{})
\`\`\`


### 66 - Использованые нулевых каналов

Имеется два следующих сниппета кода:

\`\`\`go
var ch chan int
<-ch
\`\`\`
\`\`\`go
var ch chan int
ch <- 0
\`\`\`
Оба приводят к дедлоку, но не к панике или ошибки компиляции. Дело в том, что иногда nil каналы могут быть полезны. Например, в задаче мёрджа двух каналов:

\`\`\`go
func merge(ch1, ch2 <-chan int) <-chan int {
    ch := make(chan int, 1)

    go func() {
        for ch1 != nil || ch2 != nil { // Continue if at least one channel isn’t nil
            select {
            case v, open := <-ch1:
                if !open {
                    ch1 = nil // Assign ch1 to a nil channel once closed
                    break
                }
                ch <- v
            case v, open := <-ch2:
                if !open {
                    ch2 = nil // Assigns ch2 to a nil channel once closed
                    break
                }
                ch <- v
            }
        }
        close(ch)
    }()

    return ch
}
\`\`\`
### 67 - Размер канала

Буферизованные каналы - ЗЛО. Нужно синхронизировать состояние двух горутин, чтобы точно не наткнуться на дедлок.

Однако, есть следующие исключительные случаи:

- Семафор. Можно, например, ограничить количество одновременных запросов к чему-либо с помощью буферизированного канала из необходимого количества пустых структур.
- Worker pool с известным количеством горутин, которые шарят между собой один канал. Тогда размер этого канала может быть равен количеству горутин.
### 68 - Форматирвоание строк

Найдите ошибку в коде:

\`\`\`go
type Customer struct {
    mutex sync.RWMutex // Uses a sync.RWMutex to protect concurrent accesses
    id    string
    age   int
}

func (c *Customer) UpdateAge(age int) error {
    c.mutex.Lock() // Locks and defers unlock as we update Customer
    defer c.mutex.Unlock()

    if age < 0 { // Returns an error if age is negative
        return fmt.Errorf("age should be positive for customer %v", c)
    }

    c.age = age
    return nil
}

func (c *Customer) String() string {
    c.mutex.RLock() // Locks and defers unlock as we read Customer
    defer c.mutex.RUnlock()
    return fmt.Sprintf("id %s, age %d", c.id, c.age)
}
\`\`\`

Проверка на age < 0 происходит после блокировки мьютекса. Возврат форматированной ошибки приводит к вызову функции String() для customer, которая не сможет захватить mutex, так как он уже заблокирован, а defer ещё не был вызван.

Возможное решение: проверять возраст до захвата мьютекса, возвращать в ошибке только id клиента.


### 69 - Data race при вызове append

Рассмотрим следующий код

\`\`\`go
s := make([]int, 1)

go func() { // In a new goroutine, appends a new element on s
    s1 := append(s, 1)
    fmt.Println(s1)
}()

go func() { // Same
    s2 := append(s, 1)
    fmt.Println(s2)
}()
\`\`\`

Есть ли здесь data race? Очевидно, нет, так как каждый из append возвращает новый слайс (len=1, cap=1 => пора увеличиваться)

Однако, если сделать, так:

\`\`\`go
s := make([]int, 0, 1)

go func() { 
    s1 := append(s, 1)
    fmt.Println(s1)
}()

go func() {
    s2 := append(s, 1)
    fmt.Println(s2)
}()
\`\`\`
То здесь наступает проблема. В слайсе s есть свободное место, из-за чего произойдёт гонка данных и результат будет непредсказуем.   
### 70 - Mutex при работе со слайсами и мапами

Рассмотрим следующий код:

\`\`\`go
type Cache struct {
    mu       sync.RWMutex
    balances map[string]float64
}

func (c *Cache) AddBalance(id string, balance float64) {
    c.mu.Lock()
    c.balances[id] = balance
    c.mu.Unlock()
}

func (c *Cache) AverageBalance() float64 {
    c.mu.RLock()
    balances := c.balances // Creates a copy of the balances map
    c.mu.RUnlock()

    sum := 0.
    for _, balance := range balances { // Iterates over the copy, outside of the critical section
        sum += balance
    }
    return sum / float64(len(balances))
}
\`\`\`
Что будет, если параллельно вызвать AddBalance и AverageBalance? 

Дело в том, что balances := c.balances копирует не значения, лежащие в мапе, а структуру runtime.hmap, которая содержит лишь указатели на значения. Таким образом, обе функции конкурируют за одни и те же данные, а одна из них в этот момент их меняет. Возможное решение - блокироваться на поиске среднего целиком. Если итерация предстоит долгая, проще склонировать мапу через maps.Clone().

Аналогичная ситуация со слайсами. Сам по себе слайс - лишь структура, у которой есть len, cap и указатель на нулевой элемент.
### 71 - Waitgroup

Не забывайте использовать waitgroup, иначе не будет никаких гарантий, что функция, из которой была вызвана горутина, не завершится раньше, а значит, результат работы горутины вы не узнаете (если он, конечно, вам интересен).

\`\`\`go
wg := sync.WaitGroup{}
var v uint64
for i := 0; i < 3; i++ {
    wg.Add(1)
    go func() {
        atomic.AddUint64(&v, 1)
        wg.Done()
    }()
}
wg.Wait()
fmt.Println(v)
\`\`\`
### 72 - Sync cond

Используйте sync cond, чтобы оповещать сразу несколько горутин:

\`\`\`go
type Donation struct {
    cond *sync.Cond 
    balance int
}

donation := &Donation{ 
    cond: sync.NewCond(&sync.Mutex{}), 
}

f := func(goal int) { 
    donation.cond.L.Lock() 
    for donation.balance < goal { 
        donation.cond.Wait() 
    } 
    fmt.Printf("%d$ goal reached\n", donation.balance)
    donation.cond.L.Unlock()
}
go f(10)
go f(15)
for { 
    time.Sleep(time.Second) 
    donation.cond.L.Lock() 
    donation.balance++ 
    donation.cond.L.Unlock() 
    donation.cond.Broadcast() // отпустить wait
}
\`\`\`
### 73 - Errgroup

Используйте errgroup, чтобы обработать все ошибки с нескольких горутин
### 74 - Копирование типов Sync

Не надо их копировать, весь смысл теряется тогда =)

### 75 - Неправильный time.Duration

time.Duration - alias для int64. Однако, в Go время считатеся в наносекундах, а не в микросекундах, как в большинстве других языков, так что лучше использовать специальные константы:

\`\`\`go
ticker := time.NewTicker(1000) // плохо
ticker = time.NewTicker(1000 * time.Nanosecond) // лучше
ticker = time.NewTicker(time.Microsecond) // хорошо
\`\`\`

### 76 - DEPRECATED

https://go.dev/wiki/Go123Timer
### 77 - Ошибки при работе с JSON

~~Главная ошибка - использовать стандартный маршалер~~

Что будет, если размаршалить данную структуру?

\`\`\`go
type Event1 struct {
	ID int
	time.Time
}
\`\`\`

Потеряется ID из-за того, что переменная типа времени неименованная. В том случае, когда вложенной структурой является НЕ примитив, следует быть очень осторожным (вплоть до ручного написания маршалера) (по крайней мере при работе с stdlib)

Кроме того, необходимо помнить, что time состоит из wall clock и monotonic clock, что также влияет на маршалинг и сравнение

При работе с map[any] помните, что числа по умолчанию конвертируются в float64
### 78 - Ошибки с sql

sql.Open не устанавливает соединения с базой данных, поэтому следует обязательно её пинговать

Не надо собирать запросы руками, используйте prepared statement: это и эффективнее, и спасёт от различных SQL-инъекций, так как парметры будут посланы базе отдельно именно как параметры

Для работы с nullable используйте специальные типы данных (например, sql.NullString)

Не забывайте обрабатывать ошибки, возвращаемые rows.Scan, а также rows.Err
### 79 - Закрытие ресурсов

Не забывайте закрывать os.File, sql.Rows, request.Body и всё прочее, что закрывается
### 80 - HTTP return

Не забывайте ставить return в HTTP-хэндлерах. Иначе получается следующее:

\`\`\`go
func handler(w http.ResponseWriter, req *http.Request) {
    err := foo(req)
    if err != nil {
        http.Error(w, "foo", http.StatusInternalServerError)
    }

    _, _ = w.Write([]byte("all good"))
    w.WriteHeader(http.StatusCreated)
}
\`\`\`
Ошибка записывается в ответ, но при этом выполнение функции продолжается, из-за чего ошибка окажется перезаписанной и вернётся уже created вместо 500.
### 81 - HTTP сервер и клиент из коробки

- В стандартном клиенте не определены таймауты: Dial, Handshake, ResponseHeader, Timeout(на все этапы сразу)
- В стандартном клиенте не определены настройки пула соединений: MaxIdleConns, MaxIdleConnsPerHost, IdleConnTimeout.

Аналогично для стандартного сервера:

- Не определены ReadHeaderTimeout (чтение заголовков), ReadTimeout (от начала до конца чтения тела), Timeout (чтение тела и создание ответа)
- Не определен IdleTimeout

### 82 - Классификация тестов и теги

Пирамида тестирования — это модель, которая группирует тесты по разным категориям. Юнит-тесты (или модульные тесты) находятся в основании пирамиды. Они пишутся относительно просто, быстро выполняются и высокодетерминированны. По мере продвижения вверх по пирамиде (интеграционные тесты, end2end тесты) тесты становятся более сложными для написания и более медленными при выполнении, и их детерминированность труднее гарантировать.

Рассмотрим способы классификации тестов в go:

#### Теги сборки

Рассмотрим следующий тест:

\`\`\`go
//go:build integration
package db
import (
"testing"
)
func TestInsert(t *testing.T) {
// ...
}
\`\`\`

Все тесты в этом файле будут запущены только если go test будет передан флаг --tags=integration
Аналогично, можно настроить запуск тестов только при выключенном флаге:

\`\`\`go
//go:build !integration
package db
import (
"testing"
)
func TestContract(t *testing.T) {
// ...
}
\`\`\`

#### Переменные окружения

Теги сборки имеют один главный недостаток: отсутствие сигналов о том, что тест проигнорирован.
Для избежания такой ситуации можно использовать переменные окружения:

\`\`\`go
func TestInsert(t *testing.T) {
    if os.Getenv("INTEGRATION") != "true" {
    t.Skip("skipping integration test")
    }
    // ...
}
\`\`\`

#### Короткий режим

С помощью флага -short можно запустить тесты в коротком режиме. В таком режиме можно пропускать тесты следующим образом:

\`\`\`go
func TestLongRunning(t *testing.T) {
    if testing.Short() { 
        t.Skip("skipping long-running test")
    }
    // ...
}
\`\`\`
### 83 - Флаг race

Настоятельно рекомендуется запуск тестов с флагом -race для приложений, в которых используется конкурентность. Иногда это даже обязательно. Это позволяет активировать детектор гонки, который инструментирует код для обнаружения потенциальных гонок данных. Его активация сильно влияет на производительность и значительно нагружает память, поэтому этот подход необходимо использовать в специфических обстоятельствах, например при локальном тестировании или при CI.
### 84 - Режимы тестирования

Флаг parallel позволяет выпускать тесты параллельно. Для этого нужно явно обозначить это в тесте:

\`\`\`go
func TestA(t *testing.T) {
    t.Parallel()
    // ...
}
func TestB(t *testing.T) {
    t.Parallel()
    // ...
}
func TestC(t *testing.T) {
    // ...
}
\`\`\`

Запуск тестов для этого файла выводит следующие записи:

\`\`\`js
=== RUN TestA
=== PAUSE TestA TestA приостанавливается
=== RUN TestB
=== PAUSE TestB TestB приостанавливается
=== RUN TestC Запускается TestC
--- PASS: TestC (0.00s)
=== CONT TestA TestA и TestB возобновляются
--- PASS: TestA (0.00s)
=== CONT TestB
--- PASS: TestB (0.00s)
PASS
\`\`\`

Тесты можно перемешивать с помощью флага -shuffle. Такой режим поможет выявить такие случаи, когда тесты успешно проходят только в одной последовательности.
### 85 - Табличное тестирование

Табличные тесты (table-driven tests) — это эффективный метод написания компактных тестов, позволяющий сократить избыточный код и сосредоточиться на самой логике тестирования.


Рассмотрим следующую функцию, которая удаляет из какой-то строки все символы перевода строки (\n или \r\n):

\`\`\`go
func removeNewLineSuffixes(s string) string {
    if s == "" {
        return s
    }
    if strings.HasSuffix(s, "\r\n") {
        return removeNewLineSuffixes(s[:len(s)-2])
    }
    if strings.HasSuffix(s, "\n") {
        return removeNewLineSuffixes(s[:len(s)-1])
    }
    return s
}
\`\`\`

Для такой функции можно написать следующий тест:

\`\`\`go
func TestRemoveNewLineSuffix(t *testing.T) {
    tests := map[string]struct { 
        input string
        expected string }{
        \`empty\`: { //Каждая запись в мапе представляет собой подтест
        input: "",
        expected: "",
        },
        \`ending with \r\n\`: {
        input: "a\r\n",
        expected: "a",
        },
        \`ending with \n\`: {
        input: "a\n",
        expected: "a",
        },
        \`ending with multiple \n\`: {
        input: "a\n\n\n",
        expected: "a",
        },
        \`ending without newline\`: {
        input: "a",
        expected: "a",
        },
    }
    for name, tt := range tests {
        t.Run(name, func(t *testing.T) { 
            got := removeNewLineSuffixes(tt.input) 
            if got != tt.expected { 
                t.Errorf("got: %s, expected: %s", got, tt.expected) 
            } 
        }) 
    }
}
\`\`\`


### 86 - Нестабильные тесты

Необходимо протестировать следующий код:

\`\`\`go
type Handler struct {
    n int
    publisher publisher
}

type publisher interface {
    Publish([]Foo)
}

func (h Handler) getBestFoo(someInputs int) Foo { 
    foos := getFoos(someInput) 
    best := foos[0] 
    go func() { 
        if len(foos) > h.n { 
            Foo foos = foos[:h.n] 
        } 
        h.publisher.Publish(foos)
    }() 
    return best
}
\`\`\`

Как проверить то, что ушло в publish? Например, написать его мок:

\`\`\`go
type publisherMock struct {
    mu sync.RWMutex
    got []Foo
}

func (p *publisherMock) Publish(got []Foo) {
    p.mu.Lock()
    defer p.mu.Unlock()
    p.got = got
}

func (p *publisherMock) Get() []Foo {
    p.mu.RLock()
    defer p.mu.RUnlock()
    return p.got
}

func TestGetBestFoo(t *testing.T) {
    mock := publisherMock{}
    h := Handler {
        publisher: &mock,
        n: 2,
    }   

    foo := h.getBestFoo(42) 
    time.Sleep(10 * time.Millisecond) 
    published := mock.Get()
}    
\`\`\`

Нет никакой гарантии, что нам хватит задержки в 10мс, что делает тест нестабильным. 

Например, можно задать некоторое максимальное количество попыток и промежуток между ними:

\`\`\`go
assert(t, func() bool {
    return len(mock.Get()) == 2
}, 30, time.Millisecond)
\`\`\` 

Другой вариант: использовать каналы в моке:

\`\`\`go
type publisherMock struct {
    ch chan []Foo
}

func (p *publisherMock) Publish(got []Foo) {
    p.ch <- got
}

func TestGetBestFoo(t *testing.T) {
    mock := publisherMock{
        ch: make(chan []Foo),
    }

    defer close(mock.ch)

    h := Handler{
        publisher: &mock,
        n: 2,
    }
    foo := h.getBestFoo(42)
    
    if v := len(<-mock.ch); v != 2 { 
        t.Fatalf("expected 2, got %d", v)
    }
}
\`\`\`


### 87 - API времени

Если вы используете API времени, учтите, что это может быть причиной нестабильности теста. Два основных способа решения этой проблемы:

- Мокать запросы к времени в тестах
- Запрашивать время у пользователя
### 88 - Использование пакетов утилит для тестирования

У пакета http имеется свой пакет для написания тестов - httptest:

\`\`\`go
func TestHandler(t *testing.T) { 
    req := httptest.NewRequest(http.MethodGet, "http://localhost", strings.NewReader("foo")) 
    w := httptest.NewRecorder()  
    Handler(w, req) 
    if got := w.Result().Header.Get("X-API-VERSION"); got != "1.0" { 
        t.Errorf("api version: expected 1.0, got %s", got) 
    } 
    body, _ := ioutil.ReadAll(wordy) 
    if got := string(body); got != "hello foo" { 
        t.Errorf("body: expected hello foo, got %s", got) 
    } if http.StatusOK != w.Result().StatusCode {
        t.FailNow() 
    }
}
\`\`\`

Если нужно протестировать клиент, можно использовать http.NewServer для создания заглушки того, куда будут ходить запросы.

Для работы с io.Reader и io.Writer существует пакет iotest. Например, io.Reader можно протестировать следующим образом:

\`\`\`go
func TestLowerCaseReader(t *testing.T) { 
    err := iotest.TestReader(&LowerCaseReader{
        reader: strings.NewReader("aBcDeFgHiJ")}, 
        []byte("acegi"),  
    ) 
    if err != nil { 
        t.Fatal(err) 
    }
}
\`\`\`
### 89 - Неточные бенчмарки

Любой бенчмарк в Go выглядит примерно так:

\`\`\`go
func BenchmarkFoo(b *testing.B) {
    for i := 0; i < b.N; i++ {
        foo()
    }
}
\`\`\`

В go 1.24 был добавлен b.Loop(), который решает следующие проблемы:

\`\`\`go
- Функция бенчмарка выполняется один раз на каждые -count, поэтому инициализация и очистка выполняются только один раз.

- Всё, что находится за пределами b.Loop, не влияет на время выполнения бенчмарка, поэтому b.ResetTimer не нужен.

- Компилятор никогда не оптимизирует вызовы функций внутри b.Loop
\`\`\`

#### Микробенчмарки

В микробенчмарках необходимо учитывать влияние сторонних факторов: занятость процессора, режим управления питанием, выравнивание инструкций в кэше и прочее. Например, для бенча атомиков:

\`\`\`go
func BenchmarkAtomicStoreInt32(b *testing.B) {
    var v int32
    for i := 0; i < b.N; i++ {
        atomic.StoreInt32(&v, 1)
    }
}
func BenchmarkAtomicStoreInt64(b *testing.B) {
    var v int64
    for i := 0; i < b.N; i++ {
        atomic.StoreInt64(&v, 1)
    }
}
\`\`\`

Int64 отработает быстрее. Однако, если запустить их в обратном порядке, быстрее отработает Int32. Следовательно, по результатам бенчмарков нельзя сделать вывод, что тот или иной тип данных оптимальнее.

Для большей информативности можно использовать большое количество попыток или benchstat.

#### Эффект наблюдателя

Рассмотрим следующий бенчмарк:

\`\`\`go
const rows = 1000
var res int64

func BenchmarkCalculateSum512(b *testing.B) {
    var sum int64
    s := createMatrix512(rows) Создание матрицы из 512 колонок
    b.ResetTimer()
    for i := 0; i < b.N; i++ {
        sum = calculateSum512(s) 
    }
    res = sum
}

func BenchmarkCalculateSum513(b *testing.B) {
    var sum int64
    s := createMatrix513(rows) Создание матрицы из 513 колонок
    b.ResetTimer()
    for i := 0; i < b.N; i++ {
        sum = calculateSum513(s) Вычисление суммы
    }
    res = sum
}
\`\`\`

Ожидается, что скорость будет примерно одинаковая. Однако, на практике получаем:

\`\`\`js
BenchmarkCalculateSum512-4 81854 15073 ns/op
BenchmarkCalculateSum513-4 161479 7358 ns/op
\`\`\`

В этом случае CPU пытается получить в L1 кэш подмножество матрицы, которое используется в функции Calculatesum (то есть первые восемь столбцов каждой строки). Но матрица соответствует объему памяти в одном случае (513 столбцов), а в другом (512 столбцов).

Проблема бенчмарка в том, что мы переиспользуем постоянно одну и ту же матрицу, из-за чего она кэшируется. Для корректной работы следует каждый раз создавать новую матрицу.
### 90 - Возможности тестирования в Go

#### Покрытие

Покрытие можно измерить с помощью:

\`\`\`shell
go test -coverprofile=coverage.out ./...
go tool cover -html=coverage.out
\`\`\`

#### Тестирование из другого пакета

Тесты можно выносить во внешние пакеты, чтобы убедиться в том, что в тесте не используются неэкспортируемые элементы

#### Настройка и демонтаж

Если тест требует использования стороннего ресурса, в начале можно создавать этот ресурс и освобождать с помощью defer или t.Cleanup():

\`\`\`go
func createConnection(t *testing.T, dsn string) *sql.DB {
    db, err := sql.Open("mysql", dsn)
    if err != nil {
        t.FailNow()
    }
    t.Cleanup(
    func() {
    _ = db.Close()
    })
    return db
}
\`\`\`

Также тесты можно объединить с помощью *testing.M:

\`\`\`go
func TestMain(m *testing.M) {
    setupMySQL() //Установка MySQL
    code := m.Run() //Проведение тестов
    teardownMySQL() //Демонтаж MySQL
    os.Exit(code)
}
\`\`\`
### 91 - Непонимание работы кэша CPU

Сравнение доступа по скорости:

![](cachecmp.png)

Кэш 1 уровня, очевидно, самый быстрый (кроме непосредственно регистров процессора)

Кэш-линия

Что из этого будет работать быстрее?

\`\`\`go
package main

func sum2(s []int64) int64 {
	var total int64
	for i := 0; i < len(s); i += 2 {
		total += s[i]
	}
	return total
}

func sum8(s []int64) int64 {
	var total int64
	for i := 0; i < len(s); i += 8 {
		total += s[i]
	}
	return total
}
\`\`\`

На первый взгляд, хочется сказать, что sum8, так как нужно просуммировать меньше элементов. Однако, на практике, время различается не сильно, так как основное время занимает чтение одного блока в кэш-линию (64 байт для х64 систем, 8 раз по int64), а проход внутри него получается быстрее.

\`\`\`js
cpu: AMD Ryzen 9 5900HS Creator Edition
BenchmarkSum2-12            1185            884354 ns/op               8 B/op          0 allocs/op
BenchmarkSum8-12            1596            771252 ns/op               7 B/op          0 allocs/op
\`\`\`

Предсказуемость

Что будет работать быстрее?

\`\`\`go
package main

type node struct {
	value int64
	next  *node
}

func linkedList(n *node) int64 {
	var total int64
	for n != nil {
		total += n.value
		n = n.next
	}
	return total
}

func sum2(s []int64) int64 {
	var total int64
	for i := 0; i < len(s); i += 2 {
		total += s[i]
	}
	return total
}
\`\`\`
Казалось бы, одно и то же. Однако, в массиве всё лежит рядом, а структуры разбросаны по всей памяти.

\`\`\`js
BenchmarkLinkedList-12               445           2456929 ns/op
BenchmarkSum2-12                    1342            955181 ns/op
\`\`\`

Что будет работать быстрее?

\`\`\`go
type Foo struct {
	a int64
	b int64
}

func sumFoo(foos []Foo) int64 {
	var total int64
	for i := 0; i < len(foos); i++ {
		total += foos[i].a
	}
	return total
}

type Bar struct {
	a []int64
	b []int64
}

func sumBar(bar Bar) int64 {
	var total int64
	for i := 0; i < len(bar.a); i++ {
		total += bar.a[i]
	}
	return total
}
\`\`\`

Очевидно, второй вариант, так как итерация идёт по массиву, элементы которого лежат рядом друг с другом. В случае с массивом структур же придётся переступать по памяти.

\`\`\`js
BenchmarkSumFoo-12           578           2127016 ns/op
BenchmarkSumBar-12          1040           1016268 ns/op
\`\`\`

### 92 False sharing

Что будет работать быстрее?

\`\`\`go

type Input struct {
	a int64
	b int64
}

type Result1 struct {
	sumA int64
	sumB int64
}

func count1(inputs []Input) Result1 {
	wg := sync.WaitGroup{}
	wg.Add(2)

	result := Result1{}

	go func() {
		for i := 0; i < len(inputs); i++ {
			result.sumA += inputs[i].a
		}
		wg.Done()
	}()

	go func() {
		for i := 0; i < len(inputs); i++ {
			result.sumB += inputs[i].b
		}
		wg.Done()
	}()

	wg.Wait()
	return result
}

type Result2 struct {
	sumA int64
	_    [56]byte
	sumB int64
}

func count2(inputs []Input) Result2 {
	wg := sync.WaitGroup{}
	wg.Add(2)

	result := Result2{}

	go func() {
		for i := 0; i < len(inputs); i++ {
			result.sumA += inputs[i].a
		}
		wg.Done()
	}()

	go func() {
		for i := 0; i < len(inputs); i++ {
			result.sumB += inputs[i].b
		}
		wg.Done()
	}()

	wg.Wait()
	return result
}
\`\`\`

Казалось бы, зачем добавлять в result2 лишние 56 байт. Однако, мы уже знакомы с копированием в L1-кэш блоками по 64 байта. Поскольку структура целиком вмещается в блок, копируется она разными горутинами целиком. Получается, что одна горутина обновляет поле a, другая - b, но при этом скопировали они себе по оба поля. Процессору нужно время, чтобы восстановить когерентность кэша, т. е. чтобы оба поля оказались обновлёнными.

Чуть подробнее можно почитать [здесь](https://habr.com/ru/articles/183834/)
### 93 - Параллелизм на уровне инструкций

Какой код будет работать быстрее?

\`\`\`go
const n = 1_000_000

func add(s [2]int64) [2]int64 {
	for i := 0; i < n; i++ {
		s[0]++
		if s[0]%2 == 0 {
			s[1]++
		}
	}
	return s
}

func add2(s [2]int64) [2]int64 {
	for i := 0; i < n; i++ {
		v := s[0]
		s[0] = v + 1
		if v%2 != 0 {
			s[1]++
		}
	}
	return s
}
\`\`\`

s[0] = v + 1 и v%2 != 0 процессор может выполнить параллельно, поэтому будет работать раздельно
### 94 - Выравнивание данных

Какая структура занимает меньше места?

\`\`\`go
package main

type Foo1 struct {
	b1 byte
	i  int64
	b2 byte
}

type Foo2 struct {
	i  int64
	b1 byte
	b2 byte
}
\`\`\`  

Кажется, что должно быть одинаково, так как типы данных одни и те же. Однако, на практике окажется, что Foo1 занимает 24 байта, а Foo2 - 16. Причиной этого является выравнивание данных. Выравнивание данных делается по самому большому полю (в данном случае int64 - 8 байт). Т. е. память будет поделена на блоки по 8 байт. Каждое поле должно строго умещаться в один блок, но в одном блоке может быть несколько полей структура Foo1 будет уложена в памяти так.

| x | _ | _ | _ | _ | _ | _ | _ | - b1 byte

| x | x | x | x | x | x | x | x | - i int 64

| x | _ | _ | _ | _ | _ | _ | _ | - b2 byte

Таким образом, имеем 14 неиспользуемых байт из 24 выделенных.

Для Foo2 ситуация следующая:

| x | x | x | x | x | x | x | x | - i int 64

| x | x | _ | _ | _ | _ | _ | _ | - b1,b2 byte

Теперь имеем всего 6 неиспользуемых байт из 16 выделенных



### 95 - Стек и куча

В Go переменные могут размещаться в трёх местах:

- Непосредственно рядом с кодом. Здесь лежат всякие константы.
- На стеке. Здесь обычно лежат переменные, размер которых известен на этапе компиляции. Тем не менее, стек в go является динамическим
- На куче. Здесь обычно размещаются значения (не ссылки) переменных, память для которых выделяется динамически.

Размещать переменную на стеке выгодно, так как он имеет скорость доступа O(1), в отличие от O(log n) в куче. Однако, большим объектом явно не место на стеке. Стек горутины ограничен одним гигабайтом, по умолчанию - 2 килобайта. Помните, что ресайз с эвакуацией тоже занимает время.
### 96 - Сокращение аллокаций

Какой способ вызовет меньше аллокаций?
\`\`\`go
type cache struct {
	m map[string]int
}

func (c *cache) get1(bytes []byte) (v int, contains bool) {
	key := string(bytes)
	v, contains = c.m[key]
	return
}

func (c *cache) get2(bytes []byte) (v int, contains bool) {
	v, contains = c.m[string(bytes)]
	return
}
\`\`\`

Неочевидно, но второй способ будет эффективнее. Комментарий от разработчиков говорит:


>Normally, a conversion of a byte slice to a string needs to copy the data and
causes allocations. The compiler, however, recognizes m[string(b)] and
uses the data of b directly, without copying it, because it knows that
the data can't change during the map lookup. This leads to the
counter-intuitive situation that

    k := string(b)
    println(m[k])
    println(m[k])

>will be less efficient than

    println(m[string(b)])
    println(m[string(b)])

>because the first version needs to copy and allocate, while the second
one does not.

Для переиспользования памяти рекомендуется использовать sync.Pool. sync.Pool позволяет некоторое время не освобождать память, аллоцированную для какого-либо типа данных. Таким образом, другая переменная такого же типа сможет переиспользовать её, чтобы не вызывать лишних аллокаций. Важно понимать, что время от помещения куска памяти в пул до её освобождения неизвестно.
### 97 - Встраиваемые функции

Если ваша функция очень простая, компилятор может встроить в место её вызова код самой этой функции вместо того, чтобы порождать новые вызовы, что благоприятно сказывается на оптимизации. Например:

\`\`\`go
package main

import "testing"

//go:noinline
func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}

var Result int

func BenchmarkMax(b *testing.B) {
    var r int
    for i := 0; i < b.N; i++ {
        r = max(-1, i)
    }
    Result = r
}
\`\`\`

Удаление //go:noinline (запрещает встраивание функции) ускорит программу:

\`\`\`js
BenchmarkNoInline-12         512437713                2.595 ns/op           
BenchmarkInline-12         1000000000               0.2869 ns/op    
\`\`\`


### 98 - Неиспользование профилировщика

Используйте профилировщик для отслеживания потребления ресурсов системы приложением.
### 99 - GC

В Go имеется garbage collector, который очищает неиспользуемую память с помощью алгоритма mark and sweep. Он вызывается каждый раз, когда объём кучи увеличивается в 2 раза (можно тюнинговать этот коэффициент с помощью SetGCPercent(n)), -1 для выключения. В бородатые времена он делал stop the world. Сейчас ситуация получше, но система всё ещё нагружается, из-за чего программа может тормозить. 

### 100 - GOMAXPROCS

Переменная GOMAXPROCS отвечает за то, сколько незаблокированных тредов может забрать у ОС ваша программа. Однако, планировщик задач Go живёт в своей вселенной и не очень дружит с линуксовым CFS. Поэтому, если вы в докере/кубере выставляете лимит на количество процессоров, Go не будет его учитывать, и будет использовать все процессоры хост машины. Решение: https://github.com/uber-go/automaxprocs
            `
            const marked = new Marked(
								  markedHighlight({
									emptyLangClass: 'hljs',
									langPrefix: 'hljs language-',
									highlight(code, lang, info) {
									  const language = hljs.getLanguage(lang) ? lang : 'plaintext';
									  return hljs.highlight(code, { language }).value;
									}
								  })
								);
            const html = marked.parse(markdown);
            
            document.getElementById('html-output').innerHTML = html;
        }
	convertMarkdown()
    </script>
</body>
</html>          