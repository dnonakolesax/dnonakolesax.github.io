<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Как система, процессор и компилятор стреляют нам в ноги раньше хакеров</title>
	<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.5.1/styles/github.min.css">
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 10px 0 10px 0;
        }
		img {
			width: 100%
		}
        #html-output {
            margin-bottom: 20px;
			margin-left: auto;
			margin-right: auto;
			width: 40vw;
			border: 1px solid gray;
			border-radius:12px;
			padding-left: 10px;
			padding-right: 10px;
        }
		
		@media (max-width: 768px) {
			#html-output {
				width: 90vw !important;
			}
		}
    </style>
</head>
<body>
    <div id="html-output"></div>
	<script src="https://cdn.jsdelivr.net/npm/marked/lib/marked.umd.js"></script>
	<script src="https://cdn.jsdelivr.net/npm/marked-highlight/lib/index.umd.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.5.1/highlight.min.js"></script>
    <script>
        function convertMarkdown() {
			const { Marked } = globalThis.marked;
			const { markedHighlight } = globalThis.markedHighlight;
            const markdown = `# Green Tea GC в Golang 1.26

[Назад](https://dnonakolesax.github.io/index.html)


На основе [статьи от разработчиков](https://go.dev/blog/greenteagc)

Здравствуйте, мои маленькие любители программирования. Сегодня продолжим изучать внутренности языка Golang, а именно посмотрим на новый garbage collector, который появится в версии 1.26 (в 1.25 можно включить через GOEXPERIMENT=greenteagc, но там не будет SIMD-инструкций, о которых расскажу в конце)

Вкратце напомню, в чём была идея оригинального сборщика мусора (трёхцветный mark and sweep):
1. Строится граф какой объект на какой ссылается, корневые элементы - стек и глобальные переменные. Все объекты красятся в белый
2. Корневые объекты красим в серый
3. Посещаем любой серый объект и красим в чёрный, всё, что на него указывает, помечаем серым
4. Повторяем пункт 3 пока есть серые объекты
5. Фаза sweep: всё, что оказалось белым, удаляем

Оказалось, что 90 процентов всего времени занимает разметка (mark), а сам сборщик мусора может спокойно утилизировать 20% и более времени работы CPU. При этом более 35% времени маркинга сборщик мусора шастает по памяти из-за того, что текущая его реализация не учитывает, насколько далеко друг от друга лежат объекты в графе.

Рассмотрим следующий пример:

![](https://go.dev/blog/greenteagc/marksweep-021.png)

Два объекта одного и того же типа - корневые (например, заданы как глобальные переменные). Они содержат указатели на массивы из 4 указателей того же типа. Имеется 4 куска памяти (A,B,C,D). Квадраты в правом верхнем углу - метаданные, отображающие, какие объекты были посещены. Поскольку в Go память выделяется по аренам, а в аренах спаны по одинаковому размеру, все объекты в каждом куске имеют одинаковый размер.

Итоговый порядок обхода будет выглядеть так:

![](https://go.dev/blog/greenteagc/graphflood-path.png)

Мы постоянно бегаем по далёким друг от друга адресам, что усложняет работу процессора, так как всегда быстрее обходить лежащие рядом адреса, ведь в таком случае процессор ускоряет работу с помощью кэширования, предвыборки данных и других способов. Основные проблемы такого подхода:

- Проблема NUMA (non-uniform memory access). Современные процессоры устроены так, что некоторые из ядер ходят в память быстрее, а некоторые - медленнее (собственно, поэтому и non-uniform). К тому же, время доступа к памяти зависит от того, на каком узле (сокете/контроллере памяти) физически лежит страница. Подробнее можно прочитать [здесь](https://jprahman.substack.com/p/sapphire-rapids-core-to-core-latency) (пытаться привязать процесс разметки к нужным ядрам - плохая идея в данном случае)
- Количество ядер на сокет растёт быстрее, чем число каналов DDR и их суммарная пропускная способность, поэтому в среднем пропускная способность ядра (GB/s) падает.
- Упускается возможность оптимизации алгоритма векторными (SIMD) инструкциями

Собственно, возникает идея: а давайте целиком рассматривать эти куски памяти, а не бегать туда-сюда между ними. Добавим в метаданные ещё одно поле: scanned(проверенная вершина) (seen - вершина, которая либо уже проверена, либо ещё в списке):

![](https://go.dev/blog/greenteagc/greentea-066.png)

Тогда обход той же структуры будет выглядеть гораздо проще:

![](https://go.dev/blog/greenteagc/greentea-path.png)

Теперь, когда мы мыслим не объектами, а страницами, нашему процессору проще, так как, пока мы посещали, скажем, объект x, он успел закэшировать всё то, что лежит дальше по памяти. Мы сразу посещаем их, а не то, куда ссылается x, чтобы отработать маркировку быстрее.

Теперь пришло время для магии, и называется она AVX(Advanced Vector Extensions)-инструкции, а точнее AVX512. Они появились на архитектурах AMD Zen 4 и Intel Xeon Phi / Skylake‑SP, но если у вас свежий домашний интел, их там не будет, потому что господа из интел не изволят класть их простому потребителю

![](avx512_ultra.png)

Благо, сейчас можно арендовать за копейки на месяц тачку с каким-нибудь Ryzen 9 9950X (вполне подойдёт shared cpu) и посмотреть, как там и что работает. Нас интересуют два расширения: gfni (Galois Field New Instructions) и vbmi(Vector Bit Manipulation Instructions).

Рассмотрим схему работы нового алгоритма маркировки (на этой картинке чёрный - 1, белый - 0):
![](https://go.dev/blog/greenteagc/avx512.svg)

Итак, у нас есть биты seen (1 бит - 1 объект) и scanned (аналогично). 

Находим индексы ещё не посещённых объектов, т.е. берём seen и выбираем оттуда все элементы, которые в seen 1, а в scanned - 0. Получаем биты активных объектов, т. е. тех, которые посещаем сейчас. Теперь посещёнными считаются объекты, которые есть и в scanned, и в активных. 

Теперь самая интересная часть. В работе с векторными инструкциями есть популярный трюк: вместо хождения по массиву в поисках чего-то размножить это что-то и сравнить два вектора. Например, вместо того, чтобы искать какой-то объект в массиве, можно сделать VBROADCAST(загрузить во все элементы вектора одно и то же(искомое)) и сравнивать полученный вектор с массивом, если результат не 0 - успех. Так вот, идея следующая:
- мы знаем, что каждому объекту соответствует 1 бит метаданных в active objects bit
- мы знаем, что каждый объект имеет фиксированный размер в байтах, так как они поделены по спанам
Следовательно, чтобы выделить все активные данные, а остальное зачистить, делаем следующее:
1. Размножаем метаданные в n раз, где n - размер элементов в данном спане(в машинных словах)
2. Берём нужный блок памяти и делаем И с нашими метаданными

Таким образом, остаются только активные элементы. 

Теперь возникает вопрос: как это сделать? Допустим, у нас есть следующие метаданные: 0 0 0 0 1 0 1 1, а размер объекта - 4 слова, т. е. метаданные нужно увеличить в 4 раза. В общем случае, предлагается умножить на этот вектор вот такую вот матрицу:

\`\`\`python
import numpy as np

A = np.array([
    [1,0,0,0,0,0,0,0],
    [1,0,0,0,0,0,0,0],
    [1,0,0,0,0,0,0,0],
    [1,0,0,0,0,0,0,0],
    [1,0,0,0,0,0,0,0],
    [0,1,0,0,0,0,0,0],
    [0,1,0,0,0,0,0,0],
    [0,1,0,0,0,0,0,0],
    [0,1,0,0,0,0,0,0],
    [0,0,1,0,0,0,0,0],
    [0,0,1,0,0,0,0,0],
    [0,0,1,0,0,0,0,0],
    [0,0,1,0,0,0,0,0],
    [0,0,0,1,0,0,0,0],
    [0,0,0,1,0,0,0,0],
    [0,0,0,1,0,0,0,0],
    [0,0,0,1,0,0,0,0],
    [0,0,0,0,1,0,0,0],
    [0,0,0,0,1,0,0,0],
    [0,0,0,0,1,0,0,0],
    [0,0,0,0,1,0,0,0],
    [0,0,0,0,0,1,0,0],
    [0,0,0,0,0,1,0,0],
    [0,0,0,0,0,1,0,0],
    [0,0,0,0,0,1,0,0],
    [0,0,0,0,0,0,1,0],
    [0,0,0,0,0,0,1,0],
    [0,0,0,0,0,0,1,0],
    [0,0,0,0,0,0,1,0],
    [0,0,0,0,0,0,0,1],
    [0,0,0,0,0,0,0,1],
    [0,0,0,0,0,0,0,1],
    [0,0,0,0,0,0,0,1],
])

b = np.array([0,0,0,0,1,0,1,1])

print(A@b)
#0000 0000 0000 0000 1111 0000 1111 1111
#   0    0    0    0    f    0    f    f 00 00 f0 ff <=> ff f0 00 00 (в little endian)
\`\`\`

В первых четырёх строках единица на первом месте, дальше в четырёх строках единица на втором месте итд. Действительно, получаем ожидаемый результат, но на деле всё реализовано несколько изящнее. Посмотрим, что нам предлагают разработчики. На схеме показано некоторое GF(2)^8. GF расшифровывается как Galois Field, т. е. поле Галуа. Немного ликбеза о чём вообще идёт речь:

Пусть у нас задано некоторое множество чисел. Над этим множеством определены две операции: условное сложение (+) и умножение (*). Для сложения существуют следующие аксиомы:

- Ассоциативность: (a+b)+c = a+(b+c)
- Коммутативность: a+b=b+a (Абелева группа)
- Существует такой нейтральный элемент(один и только один) 0, такой что: a+0=a
- Для каждого a существует такой обратный по сложению элемент -a, что a + (-a) = 0

Для умножения:

- Ассоциативность (a\*b)\*c=a*(b\*c)
- Существует такой нейтральный элемент(один и только один) 1, такой что: a\*1=1\*a=a (не обязательно)

Заметим, что нейтральный элемент 1, а не 0, так как результатом операции с некоторым операндом и нейтральным элементом должен быть этот самый операнд.

Дистрибутивность для обеих операций:

- a\*(b+c) = a\*b + a\*c
- (a+b)\*c = a\*c + b\*c

Это и называется кольцом. Кольцо - вещь интересная, можно например, провернуть следующий фокус: пусть имеется кольцо Z[sqrt(−5)]={a+b\*sqrt(−5)∣a,b∈Z}. Основная теорема арифметики гласит, что любое натуральное число больше 1 либо само является простым, либо может быть представлено в виде произведения простых чисел, причём единственным способом. Однако в нашем кольце 6=2⋅3=(1+sqrt(−5))(1−sqrt(−5)). Теперь вы понимаете [умный анекдот для физтеховцев](https://www.youtube.com/watch?v=xwvKcWa2vLM)!

Поле - это такое кольцо, где для умножения выполняются ещё две аксиомы:

- Коммутативность умножения a\*b=b\*a (например, для матриц такое условие не выполняется)
- Для любого ненулевого элемента существует такой a^(-1), что a\*a^(-1)=1
Единица должна существовать и не должна быть равна нулю (нейтральному элементу сложения).

Поле Галуа - это конечное поле, т. е. оно состоит из конечного числа элементов. В нашем случае поле определяется следующим образом:

- Элементы: 0,1
- Операция сложения: XOR(исключающее или, 0 если оба операнда 0 или оба операнда 1, иначе 1)
- Операция умножения: AND(логическое и, 1 когда оба операнда 1, иначе 0)

Важно отметить, что это не то GF(2^8), как в AES (там элементы не 0,1, а 0..FF(255) + чуть другое умножение). Здесь каждый байт рассматривается как вектор из 8 бит над GF(2), и к нему применяется аффинное преобразование.

Посмотрим, какие инструкции использует новый сборщик мусора. Заглянем в [исходники](https://github.com/golang/go/blob/release-branch.go1.26/src/internal/runtime/gc/scan/expand_amd64.s) (src/internal/runtime/gc/scan/expand_amd64.s). Это ассемблерный автоген, где наделано множество функций для разного размера объектов в спане(например, expandAVX512_4 - для объектов размером в 4 машинных слова), на его примере и посмотрим работу алгоритма. Его код:

\`\`\`
TEXT expandAVX512_4<>(SB), NOSPLIT, $0-0
	VMOVDQU64 expandAVX512_4_inShuf0<>(SB), Z0
	VMOVDQU64 expandAVX512_4_mat0<>(SB), Z1
	VMOVDQU64 expandAVX512_4_inShuf1<>(SB), Z2
	VMOVDQU64 expandAVX512_4_outShufLo(SB), Z3
	VMOVDQU64 (AX), Z4
	VPERMB Z4, Z0, Z0
	VGF2P8AFFINEQB $0, Z1, Z0, Z0
	VPERMB Z4, Z2, Z2
	VGF2P8AFFINEQB $0, Z1, Z2, Z2
	VPERMB Z0, Z3, Z1
	VPERMB Z2, Z3, Z2
	RET
\`\`\`

Выглядит сложно, но на деле нужно разобрать всего две команды: VGF2P8AFFINEQB и VPERMB. VMOVDQU64 просто загружает данные в 64-байтовые регистры из констант или регистра AX(входной параметр). RET - аналог return. Принимает наша функция на вход 64 байта (на самом деле, для 4 значимых только 32 - дальше скажу почему), а возвращает 128.

Для дебага можно собрать следующий проект. Структура: 

\`\`\`bash
.
├── expander
│   ├── expand4_amd64.go
│   └── expand4_amd64.s
├── go.mod
├── go.sum
└── main.go
\`\`\`

Инициализируем модуль: go mod init <имя модуля> и ставим go get golang.org/x/sys/cpu.

expander/expand4_amd64.go:

\`\`\`go
//go:build amd64

package expander

import (
	"unsafe"

	"golang.org/x/sys/cpu"
)

type Expand4Debug struct {
	InZ4         [64]byte // Z4 после VMOVDQU64 (AX), Z4
	AfterPermb0  [64]byte // Z0 после VPERMB Z4, Z0, Z0
	AfterAffine0 [64]byte // Z0 после VGF2P8AFFINEQB
	AfterPermb1  [64]byte // Z2 после VPERMB Z4, Z2, Z2
	AfterAffine1 [64]byte // Z2 после VGF2P8AFFINEQB
	OutLoZ1      [64]byte // Z1 после VPERMB Z0, outShufLo, Z1
	OutHiZ2      [64]byte // Z2 после VPERMB Z2, outShufLo, Z2
}

func hasAVX512ExpandReqs() bool {
	// Минимально нужно: VBMI (VPERMB) + GFNI (AFFINE) + (VL/BW/F обычно как база для ZMM-регистров).
	return cpu.X86.HasAVX512VL &&
		cpu.X86.HasAVX512BW &&
		cpu.X86.HasAVX512VBMI &&
		cpu.X86.HasAVX512GFNI
}

// dbg можно передать nil.
func Expand4(in *[64]byte, out *[128]byte, dbg *Expand4Debug) {
	if !hasAVX512ExpandReqs() {
		panic("need AVX-512: VL,BW,VBMI,GFNI")
	}
	expand4AVX512Dbg(unsafe.Pointer(&in[0]), unsafe.Pointer(&out[0]), unsafe.Pointer(dbg))
}

//go:noescape
func expand4AVX512Dbg(in unsafe.Pointer, out unsafe.Pointer, dbg unsafe.Pointer)
\`\`\`


expander/expand4_amd64.s (здесь немного наколхожено разного для дебага):

\`\`\`wasm
//go:build amd64

#include "go_asm.h"
#include "textflag.h"

// константы из оригинального файла
GLOBL ·expand4_inShuf0<>(SB), RODATA, $0x40
DATA  ·expand4_inShuf0<>+0x00(SB)/8, $0x0706050403020100
DATA  ·expand4_inShuf0<>+0x08(SB)/8, $0x0706050403020100
DATA  ·expand4_inShuf0<>+0x10(SB)/8, $0x0706050403020100
DATA  ·expand4_inShuf0<>+0x18(SB)/8, $0x0706050403020100
DATA  ·expand4_inShuf0<>+0x20(SB)/8, $0x0f0e0d0c0b0a0908
DATA  ·expand4_inShuf0<>+0x28(SB)/8, $0x0f0e0d0c0b0a0908
DATA  ·expand4_inShuf0<>+0x30(SB)/8, $0x0f0e0d0c0b0a0908
DATA  ·expand4_inShuf0<>+0x38(SB)/8, $0x0f0e0d0c0b0a0908

GLOBL ·expand4_mat0<>(SB), RODATA, $0x40
DATA  ·expand4_mat0<>+0x00(SB)/8, $0x0101010102020202
DATA  ·expand4_mat0<>+0x08(SB)/8, $0x0404040408080808
DATA  ·expand4_mat0<>+0x10(SB)/8, $0x1010101020202020
DATA  ·expand4_mat0<>+0x18(SB)/8, $0x4040404080808080
DATA  ·expand4_mat0<>+0x20(SB)/8, $0x0101010102020202
DATA  ·expand4_mat0<>+0x28(SB)/8, $0x0404040408080808
DATA  ·expand4_mat0<>+0x30(SB)/8, $0x1010101020202020
DATA  ·expand4_mat0<>+0x38(SB)/8, $0x4040404080808080

GLOBL ·expand4_inShuf1<>(SB), RODATA, $0x40
DATA  ·expand4_inShuf1<>+0x00(SB)/8, $0x1716151413121110
DATA  ·expand4_inShuf1<>+0x08(SB)/8, $0x1716151413121110
DATA  ·expand4_inShuf1<>+0x10(SB)/8, $0x1716151413121110
DATA  ·expand4_inShuf1<>+0x18(SB)/8, $0x1716151413121110
DATA  ·expand4_inShuf1<>+0x20(SB)/8, $0x1f1e1d1c1b1a1918
DATA  ·expand4_inShuf1<>+0x28(SB)/8, $0x1f1e1d1c1b1a1918
DATA  ·expand4_inShuf1<>+0x30(SB)/8, $0x1f1e1d1c1b1a1918
DATA  ·expand4_inShuf1<>+0x38(SB)/8, $0x1f1e1d1c1b1a1918

GLOBL ·expand4_outShufLo<>(SB), RODATA, $0x40
DATA  ·expand4_outShufLo<>+0x00(SB)/8, $0x1911090118100800
DATA  ·expand4_outShufLo<>+0x08(SB)/8, $0x1b130b031a120a02
DATA  ·expand4_outShufLo<>+0x10(SB)/8, $0x1d150d051c140c04
DATA  ·expand4_outShufLo<>+0x18(SB)/8, $0x1f170f071e160e06
DATA  ·expand4_outShufLo<>+0x20(SB)/8, $0x3931292138302820
DATA  ·expand4_outShufLo<>+0x28(SB)/8, $0x3b332b233a322a22
DATA  ·expand4_outShufLo<>+0x30(SB)/8, $0x3d352d253c342c24
DATA  ·expand4_outShufLo<>+0x38(SB)/8, $0x3f372f273e362e26

// func expand4AVX512Dbg(in unsafe.Pointer, out unsafe.Pointer, dbg unsafe.Pointer)
TEXT ·expand4AVX512Dbg(SB), NOSPLIT, $0-24
	MOVQ in+0(FP), AX
	MOVQ out+8(FP), DI
	MOVQ dbg+16(FP), DX  // DX = dbg (может быть 0)

	VMOVDQU64 ·expand4_inShuf0<>(SB), Z0
	VMOVDQU64 ·expand4_mat0<>(SB),   Z1
	VMOVDQU64 ·expand4_inShuf1<>(SB), Z2
	VMOVDQU64 ·expand4_outShufLo<>(SB), Z3

	VMOVDQU64 (AX), Z4
	TESTQ DX, DX
	JEQ  nodbg_in
	VMOVDQU64 Z4, 0(DX)      // InZ4
nodbg_in:

	VPERMB Z4, Z0, Z0
	TESTQ DX, DX
	JEQ  nodbg_p0
	VMOVDQU64 Z0, 64(DX)     // AfterPermb0
nodbg_p0:

	VGF2P8AFFINEQB $0, Z1, Z0, Z0
	TESTQ DX, DX
	JEQ  nodbg_a0
	VMOVDQU64 Z0, 128(DX)    // AfterAffine0
nodbg_a0:

	VPERMB Z4, Z2, Z2
	TESTQ DX, DX
	JEQ  nodbg_p1
	VMOVDQU64 Z2, 192(DX)    // AfterPermb1
nodbg_p1:

	VGF2P8AFFINEQB $0, Z1, Z2, Z2
	TESTQ DX, DX
	JEQ  nodbg_a1
	VMOVDQU64 Z2, 256(DX)    // AfterAffine1
nodbg_a1:

	VPERMB Z0, Z3, Z1
	TESTQ DX, DX
	JEQ  nodbg_o1
	VMOVDQU64 Z1, 320(DX)    // OutLoZ1
nodbg_o1:

	VPERMB Z2, Z3, Z2
	TESTQ DX, DX
	JEQ  nodbg_o2
	VMOVDQU64 Z2, 384(DX)    // OutHiZ2
nodbg_o2:

	VMOVDQU64 Z1, 0(DI)
	VMOVDQU64 Z2, 64(DI)
	VZEROUPPER
	RET
\`\`\`

main.go:

\`\`\`go
package main

import (
	"fmt"

	"whatever/expander"
)

func main() {
	var in [64]byte
	for i := range in {
		in[i] = byte(i*37 + 11)
		// вход 64, но для х4 значимы только 32, так как выход 128; 128*8=1024; 1024/4(во сколько умножать)/8=32(макс кол-во значимых байт из 64)
		if (i >= 32) {
			in[i] = 0
		}
	}
	var out [128]byte
	var dbg expander.Expand4Debug

	expander.Expand4(&in, &out, &dbg)

	fmt.Printf("in[0:64]        = % x\n", in[:64])
	fmt.Printf("Z4[0:64]        = % x\n", dbg.InZ4[:64])
	fmt.Printf("permb0 Z0[0:64] = % x\n", dbg.AfterPermb0[:64])
	fmt.Printf("aff0   Z0[0:64] = % x\n", dbg.AfterAffine0[:64])
	fmt.Printf("permb1 Z2[0:64] = % x\n", dbg.AfterPermb1[:64])
	fmt.Printf("aff1   Z2[0:64] = % x\n", dbg.AfterAffine1[:64])
	fmt.Printf("out Z1[0:64]    = % x\n", dbg.OutLoZ1[:64])
	fmt.Printf("out Z2[0:64]    = % x\n", dbg.OutHiZ2[:64])
	fmt.Printf("out[0:128]       = % x\n", out[:128])
}
\`\`\`

Итак, функция возвращает 128 байт. Поскольку расширяем в 4 раза, максимум можем передать 128/4=32байта, остальные не будут иметь никакого смысла. Сгенерируем их случайно и получим результат:

\`\`\`bash
in[0:64] = 0b 30 55 7a 9f c4 e9 0e 33 58 7d a2 c7 ec 11 36 5b 80 a5 ca ef 14 39 5e 83 a8 cd f2 17 3c 61 86 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
Z4[0:64] = 0b 30 55 7a 9f c4 e9 0e 33 58 7d a2 c7 ec 11 36 5b 80 a5 ca ef 14 39 5e 83 a8 cd f2 17 3c 61 86 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
permb0 Z0[0:64] = 0b 30 55 7a 9f c4 e9 0e 0b 30 55 7a 9f c4 e9 0e 0b 30 55 7a 9f c4 e9 0e 0b 30 55 7a 9f c4 e9 0e 33 58 7d a2 c7 ec 11 36 33 58 7d a2 c7 ec 11 36 33 58 7d a2 c7 ec 11 36 33 58 7d a2 c7 ec 11 36
aff0 Z0[0:64] = ff 00 0f f0 ff 00 0f f0 f0 00 0f f0 ff 0f f0 ff 00 ff 0f ff 0f 00 f0 00 00 00 0f 0f f0 ff ff 00 ff 00 0f f0 ff 00 0f f0 00 f0 ff 00 0f ff 00 0f ff 0f ff f0 00 f0 0f ff 00 0f 0f f0 ff ff 00 00
permb1 Z2[0:64] = 5b 80 a5 ca ef 14 39 5e 5b 80 a5 ca ef 14 39 5e 5b 80 a5 ca ef 14 39 5e 5b 80 a5 ca ef 14 39 5e 83 a8 cd f2 17 3c 61 86 83 a8 cd f2 17 3c 61 86 83 a8 cd f2 17 3c 61 86 83 a8 cd f2 17 3c 61 86
aff1 Z2[0:64] = ff 00 0f f0 ff 00 0f f0 f0 00 0f f0 ff 0f f0 ff 0f 00 f0 00 f0 0f ff 0f 0f f0 f0 ff ff 00 00 0f ff 00 0f f0 ff 00 0f f0 00 f0 ff 00 0f ff 00 0f 00 f0 00 ff 0f ff f0 00 f0 f0 ff ff 00 00 0f f0
out Z1[0:64] = ff f0 00 00 00 00 ff 00 0f 0f 0f 0f f0 f0 ff 0f ff ff 0f f0 00 0f 00 ff 0f f0 f0 ff f0 ff 00 00 ff 00 ff 00 00 f0 0f 0f 0f ff ff 0f f0 00 f0 f0 ff 0f 00 ff 00 ff f0 ff 0f 00 0f 00 f0 0f ff 00
out Z2[0:64] = ff f0 0f 0f 00 00 00 f0 0f 0f f0 f0 f0 f0 00 ff ff ff f0 ff 00 0f 0f 00 0f f0 ff 00 f0 ff 0f 0f ff 00 00 f0 00 f0 f0 f0 0f ff 00 ff f0 00 ff ff ff 0f 0f 00 00 ff ff 00 0f 00 f0 0f f0 0f 00 f0
out[0:128] = ff f0 00 00 00 00 ff 00 0f 0f 0f 0f f0 f0 ff 0f ff ff 0f f0 00 0f 00 ff 0f f0 f0 ff f0 ff 00 00 ff 00 ff 00 00 f0 0f 0f 0f ff ff 0f f0 00 f0 f0 ff 0f 00 ff 00 ff f0 ff 0f 00 0f 00 f0 0f ff 00 ff f0 0f 0f 00 00 00 f0 0f 0f f0 f0 f0 f0 00 ff ff ff f0 ff 00 0f 0f 00 0f f0 ff 00 f0 ff 0f 0f ff 00 00 f0 00 f0 f0 f0 0f ff 00 ff f0 00 ff ff ff 0f 0f 00 00 ff ff 00 0f 00 f0 0f f0 0f 00 f0
\`\`\`

Если вылезла паника need AVX-512: VL,BW,VBMI,GFNI - процессор не поддерживает нужные инструкции.

Рассмотрим строчку [VPERMB](https://www.felixcloutier.com/x86/vpermb) (Vector Permutate Bytes) Z4, Z0, Z0. Что она сделала по сути: взяла первые 16 байт из наших 32 и зациклила их по 4 раза: сначала 4 раза по 0b 30 55 7a 9f c4 e9 0e, затем 4 раза по 33 58 7d a2 c7 ec 11 36. Напоминаю, что в Z4 у нас лежат исходные данные, а в Z0 следующая константа:

\`\`\`wasm
GLOBL ·expand4_inShuf0<>(SB), RODATA, $0x40
DATA  ·expand4_inShuf0<>+0x00(SB)/8, $0x0706050403020100
DATA  ·expand4_inShuf0<>+0x08(SB)/8, $0x0706050403020100
DATA  ·expand4_inShuf0<>+0x10(SB)/8, $0x0706050403020100
DATA  ·expand4_inShuf0<>+0x18(SB)/8, $0x0706050403020100
DATA  ·expand4_inShuf0<>+0x20(SB)/8, $0x0f0e0d0c0b0a0908
DATA  ·expand4_inShuf0<>+0x28(SB)/8, $0x0f0e0d0c0b0a0908
DATA  ·expand4_inShuf0<>+0x30(SB)/8, $0x0f0e0d0c0b0a0908
DATA  ·expand4_inShuf0<>+0x38(SB)/8, $0x0f0e0d0c0b0a0908
\`\`\`

Именно она и указывает нам, по каким индексам забирать элементы из Z4 в Z0: четыре раза 0,1,2,3,4,5,6,7 (напоминаю, что у нас Little Endian, поэтому читаем с конца) и четыре раза по 8,9,10,11,12,13,14,15(8-F, напоминаю, что работаем в 16ричной системе). Результат был также записан в Z0(третий операнд). 

Следующая операция - [VGF2P8AFFINEQB](https://www.felixcloutier.com/x86/gf2p8affineqb) (Афинное преобразование в поле Галуа {0,1} для слов по 8 байт) $0, Z1, Z0, Z0. Преобразование имеет вид A\*x+b, где * и + - раннее определённые нами операции (И и XOR), b имеет константное значение (в нашем случае - 0). В Z0 лежит результат предыдущей инструкции, в Z1 следующая константа: 

\`\`\`wasm
GLOBL ·expand4_mat0<>(SB), RODATA, $0x40
DATA  ·expand4_mat0<>+0x00(SB)/8, $0x0101010102020202
DATA  ·expand4_mat0<>+0x08(SB)/8, $0x0404040408080808
DATA  ·expand4_mat0<>+0x10(SB)/8, $0x1010101020202020
DATA  ·expand4_mat0<>+0x18(SB)/8, $0x4040404080808080
DATA  ·expand4_mat0<>+0x20(SB)/8, $0x0101010102020202
DATA  ·expand4_mat0<>+0x28(SB)/8, $0x0404040408080808
DATA  ·expand4_mat0<>+0x30(SB)/8, $0x1010101020202020
DATA  ·expand4_mat0<>+0x38(SB)/8, $0x4040404080808080
\`\`\`

Каждая строка представляет собой матрицу 8х8 бит, которая и будет той самой матрицей A. В качестве x - значения из Z0, b равен нулю, не учитываем его. Инструкция рассматривает каждый байт как вектор из 8 элементов и умножает его на 8х8 битовую матрицу. 

При k=4 естественная упаковка - по два объекта на байт выхода (2×4 бита = 8 бит). Поэтому:

- lane0 делает пару (x0,x1) -> один байт
- lane1 делает (x2,x3)
- lane2 делает (x4,x5)
- lane3 делает (x6,x7)
- lane4: снова (x0, x1), но уже для байтов 8..15
- lane5: снова (x2, x3) для байтов 8..15
- lane6: снова (x4, x5) для байтов 8..15
- lane7: снова (x6, x7) для байтов 8..15

(а дальше это повторяется для других lane/половин, а outShufLo потом раскладывает всё в линейный word-bitmap).

Один и тот же входной байт x должен одновременно попасть в lane0..lane3, чтобы за один проход получить 4 байта результата:
- байт для (x0,x1)
- байт для (x2,x3)
- байт для (x4,x5)
- байт для (x6,x7)

Первые 4 qword в inShuf0 одинаковые (0..7) => в lane0..lane3 кладутся одни и те же 8 входных байт. Следующие 4 qword (8..15) => в lane4..lane7 кладутся байты 8..15.

Далее чуть более хитрым способом (с лишним шаффлом) обрабатываем вторую часть и склеиваем в одну. Получаем нужный результат.

Поскольку мы обошлись памятью регистров, а также малым количеством команд, получается очень быстро и эффективно. Для интересующихся - [ссылка на генератор преобразователей](https://github.com/golang/go/blob/release-branch.go1.26/src/internal/runtime/gc/scan/mkasm.go)

Теперь можно пройтись по памяти страницы и собрать все указатели, т. е. для каждого установленного бита в bitmap активных указателей загрузить значение указателя из соответствующего слова и записать его в буфер, который позже будет использован для пометки найденных объектов и добавления страниц в список задач.

Даже без векторных ускорений затраты CPU на сборку мусора снизились на 10-40%, а векторные улучшения могут потенциально скинуть ещё 10%. 

Минусом такого подхода является работа со страницами, где находится всего один объект. Разработчики добавили костыль, который чуть уменьшает деградацию в таком случае, но это всё ещё неприятно. Если хотя бы 2% страницы сканируется за 1 раз - это уже лучше старого алгоритма.

Домашнее задание: разобрать баг на AMD Zen 4 (исправлен на Zen 5): https://github.com/golang/go/blob/76e4bd2a57df870ac65973ff0404e7f3cb329c2f/src/internal/runtime/gc/scan/scan_amd64.s#L87C2-L103C115
                        `
            const marked = new Marked(
								  markedHighlight({
									emptyLangClass: 'hljs',
									langPrefix: 'hljs language-',
									highlight(code, lang, info) {
									  const language = hljs.getLanguage(lang) ? lang : 'plaintext';
									  return hljs.highlight(code, { language }).value;
									}
								  })
								);
            const html = marked.parse(markdown);
            
            document.getElementById('html-output').innerHTML = html;
        }
	convertMarkdown()
    </script>
</body>
</html>          