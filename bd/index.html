<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>VKAT V GO</title>
	<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.5.1/styles/github.min.css">
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 10px 0 10px 0;
        }
		img {
			width: 100%
		}
        #html-output {
            margin-bottom: 20px;
			margin-left: auto;
			margin-right: auto;
			width: 40vw;
			border: 1px solid gray;
			border-radius:12px;
			padding-left: 10px;
			padding-right: 10px;
        }
		
		@media (max-width: 768px) {
			#html-output {
				width: 90vw !important;
			}
		}
    </style>
</head>
<body>
    <div id="html-output"></div>
	<script src="https://cdn.jsdelivr.net/npm/marked/lib/marked.umd.js"></script>
	<script src="https://cdn.jsdelivr.net/npm/marked-highlight/lib/index.umd.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.5.1/highlight.min.js"></script>
    <script>
        function convertMarkdown() {
			const { Marked } = globalThis.marked;
			const { markedHighlight } = globalThis.markedHighlight;
            const markdown = `
# БД

[Назад](https://dnonakolesax.github.io/)

## SQL

SQL (Structured Query Language, язык структурированных запросов) - декларативный ЯП для создания, модификации и управления данными в реляционной БД

Реляционная БД основана на реляционной модели данных (relation, отношение) и поддерживает операторы реляционной алгебры. Обычно отношением называют таблицу, хотя это скорее не само отношение, а её представление.

Базовые команды в SQL:

- CREATE - создать
- ALTER - модифицировать
- DROP - удалить
- SELECT - извлечь из одной или нескольких таблиц
- INSERT - создать записи
- UPDATE - модифицировать записи
- DELETE - удалить записи
- TRUNCATE - очистить таблицу
- GRANT - выдать пользователю права
- REVOKE - забрать у пользователя права
- BEGIN - начать транзакцию
- COMMIT - подтвердить транзакцию
- ROLLBACK - откатить транзакцию

Select X записей с отступом в Y:
\`\`\`sql
SELECT ... LIMIT X, OFFSET Y
\`\`\`

Select с упорядочиванием:
\`\`\`sql
SELECT ... ORDER BY
\`\`\`

Select из нескольких таблиц:
\`\`\`sql
SELECT ... JOIN
\`\`\`

Select без дубликатов:

\`\`\`sql
SELECT DISTINCT ...
\`\`\`

Select с группировкой по полю с возможностью последующего применения функций (count, max, min, avg, sum):

\`\`\`sql
SELECT ... GROUP BY ... HAVING <условие для группировки>
\`\`\`

### Оконные функции

Помимо обычных функций, существуют также оконные функции, позволяющие выполнять вычисления для набора строк в определённом окне или диапазоне

\`\`\`sql
SELECT
    id,
    section,
    header,
    score,
    row_number() OVER (PARTITION BY section ORDER BY score DESC)  AS rating_in_section
FROM news
ORDER BY section, rating_in_section;
\`\`\`
| id | section |  header   | score | rating_in_section 
|---|---------|-----------|-------|-------------------
  2 |       1 | Заголовок |     6 |                 1
  6 |       2 | Заголовок |    95 |                 1
  5 |       2 | Заголовок |    34 |                 2
  1 |       2 | Заголовок |    23 |                 3
  4 |       3 | Заголовок |    36 |                 1
  8 |       3 | Заголовок |    36 |                 2
  3 |       4 | Заголовок |    79 |                 1
  7 |       4 | Заголовок |    26 |                 2

### Связи между таблицами:

- 1 to 1 - одной записи в одной таблице соответствует одна запись в другой таблице.
- 1 to M - одной записи в одной таблице соответствуют несколько записей в другой таблице. Для связи используется FK.
- M to M  - нескольким записям в одной таблице соответствуют несколько записей в другой таблице. Для связи используется отдельная таблица.

Схема БД включает в себя информацию о таблицах, триггерах, хранимых процедурах, индексах, view итд

Нормальная форма - свойство, отражающее степень избыточности данных в таблице.
Нормализация - приведение к той или иной НФ:

### 0НФ

Абсолютно любая БД, у которой нет повторения строк в таблице

### 1НФ

0НФ + каждый кортеж отношения содержит только одно значение для каждого из атрибутов, т. е.

|     A     |     B     |
|-----------|-----------|
|     C     | {D,E,F,G} |

Следует превратить в:

|     A     |     B     |
|-----------|-----------|
|     C     |     D     |
|     C     |     E     |
|     C     |     F     |
|     C     |     G     |

Если, конечно, это возможно логически

### 2НФ

1НФ + каждый неключевой элемент неприводимо зависит от потенциального ключа

Пример из википедии (PK = филиал + должность):

|Филиал компании|Должность|Зарплата|Наличие компьютера|
|---------------|---------|--------|------------------|
|A              |Охранник |7777777 |false             |
|B              |Эникей   |77777   |true              |
|A              |Эникей   |88888   |true              |

Очевидно, наличие компьютера зависит от должности, а зарплата и от должности, и от филиала. Значит, чтобы перейти во 2НФ, нужно вывести должность и наличие компьютера в отдельную таблицу.

### 3НФ

2НФ + отсутствие транзитивной функциональной зависимости неключевого элемента от потенциального ключа

Другими словами, не должно быть таких неключевых полей, которые зависят от других неключевых

Пример из википедии (PK = сотрудник):

|Сотрудник|Отдел|Телефон|
|---------|-----|-------|
|Сванов   |A    |8952812|
|Иетров   |A    |8952812|
|Пидоров  |B    |2281337|

Здесь телефон сотрудника зависит от отдела, а не от фамилии сотрудника. Следовательно, таблицу следует разделить на две: сотрудник-отдел и отдел-телефон.

Обычно всё делается в 3НФ. Дальше уже начинается задротство

### НФБК (Бойса-Кодда)

Усиленная 3НФ для тех случаев, когда в отношении не один потенциальный ключ.

Пример из википедии (бронирование теннисных кортов):

|Корт|Время начала|Время конца|Тариф|
|----|------------|-----------|-----|
|1   |0930        |1030       |SAVER|
|1   |1100        |1200       |SAVER|
|1   |1400        |1530       |STD  |
|2   |1000        |1130       |VIP A|
|2   |1130        |1330       |VIP B|
|2   |1500        |1630       |VIP B|

Для каждого из кортов есть два тарифа: один из них для членов клуба, другой - для остальных.

В качестве PK можно выбрать:
- Корт + время начала
- Корт + время конца
- Тариф + время начала
- Тариф + время конца

Тариф снова зависит от корта, но не напрямую, как в предыдущем примере, а косвенно: каждый тариф принадлежит конкретному корту, но у корта несколько тарифов. Следовательно, нужно вынести тарифы в отдельную таблицу:

|Корт|Тариф|Для членов|
|----|-----|----------|
|1   |SAVER|True      |
|1   |STD  |False     |
|2   |VIP A|True      |
|2   |VIP B|False     |

Не всегда можно перейти в НФБК. Для таких случаев существует другая форма:

### EKNF (Нормальная форма с элементарным ключом)

Таблица ближайшие магазины:

|Фамилия|Ближайший магазин|Тип магазина|
|-------|-----------------|------------|
|Сванов |Шестёрочка       |Ларёк       |
|Сванов |КБ               |Пивнуха     |
|Иетров |ДНС              |Электроника |
|Пидоров|Спортмастер      |Одежда      |
|Пидоров|КБ               |Пивнуха     |
|Пидоров|Шестёрочка       |Ларёк       |

Тип магазина зависит от ближайшего магазина. Однако, если перевести в НФБК, получатся две таблицы:

Ближайшие магазины
|Фамилия|Магазин|  
|-------|-------|

И

Типы магазинов
|Магазин|Тип магазина|
|-------|-------|

Однако, в таком случае, мы не можем гарантировать, что у одного человека не будет двух ближайших магазинов одного и того же типа.
Нормальная форма с элементарным ключом предлагает использовать оригинальную таблицу и таблицу "типы магазинов". Нужно навесить ограничение на совпадение магазин;тип магазина в обеих таблицах.

### 4НФ
НФБК + нетривиальные многозначные зависимости фактически являются функциональными зависимостями от ее потенциальных ключей.

Рассмотрим следующую таблицу:

|Ресторан|Вид пиццы|Зона доставки|
|--------|---------|-------------|

Очевидно, нет никакой зависимости между видами пиццы и зонами доставки, так как любую пиццу можно доставить в любую точку, куда доставляет ресторан. Следовательно, эту таблицу можно разбить на две

### ETNF

Что-то строго между 4НФ и 5НФ, в принципе никого не волнует её существование, можно и забить.

### 5НФ

Каждая нетривиальная зависимость соединения в нём определяется потенциальным ключом (ключами) этого отношения

Если разорвать зависимость соединения, получится декомпозиция с потерями. 

Например, для таблицы:

|Город|Страна|Столица?|
|-----|------|--------|

Декомпозиция с потерями:

|Город|   
|-----|


|Страна|Столица?|
|-|-| 

Без потерь:

|Город|Страна|  
|-----|------|


|Город|Столица?|  
|-----|------|

Рассмотрим следующую таблицу:

|Продавец|Фирма  |Товар|
|--------|-------|-----|

Каждый продавец имеет в своём ассортименте ограниченный список фирм и ограниченный список типов товаров и предлагает товары из списка товаров, производимые фирмами из списка фирм. 

Следовательно, таблицу следует разбить на следующие:

|Продавец|Товар|
|--------|-----|

|Фирма|Товар|
|--------|-----|

|Продавец|Фирма|
|--------|-----|

### ДКНФ (Доменно-Ключевая)

Переменная отношения находится в ДКНФ тогда и только тогда, когда каждое наложенное на неё ограничение является логическим следствием ограничений доменов и ограничений ключей, наложенных на данную переменную отношения. 

Рассмотрим следующую таблицу:

Олигархи
|Фамилия|Тип|Состояние|
|-------|---|---------|
|Сванов |Доширарх|$100|
|Пидоров|Олигарх|$100_000_000_000|
|Иетров|Доширарх|$1|
|Листерман|Дохерарх|$1_000_000_000_000|

Поле "Тип" в данном случае является лишним. Его следует вынести в отдельную таблицу:

Типы олигархов:

|Тип|Минимальное состояние|Максимальное состояние|
|-|-|-|
|Доширарх|0|99_999_999_999|
|Олигарх|100_000_000_000|999_999_999_999|
|Дохерарх|1_000_000_000_000|999_999_999_999_999|

### 6НФ
5НФ + переменная находится в 6НФ тогда и только тогда, когда она неприводима, то есть не может быть подвергнута дальнейшей декомпозиции без потерь

Допустим, есть следующий пример:

|Medic ID| 	Medic Name| 	Occupation |	Type| 	Practice in years|
|-|-|-|-|-|

Эту таблицу можно раскидать на 4 таблицы из двух колонок, в каждой из которой PK будет Medic ID. 

В принципе, про всё, что после 3НФ надо просто помнить, а при проектировании базы руководствоваться текущими требованиями и здравым смыслом.

### JOIN

Типы джоинов проще всего понять по картинке:

![join](https://storage.yandexcloud.net/gpages/join.png) 

### Триггеры

Триггеры срабатывают до или после определённых действий(вставки, удаления, ...) и выполняют некоторую функцию

### Explain

Чтобы посмотреть, как БД будет выполнять запрос, и сколько это будет стоить, можно вызвать команду Explain
Чтобы заодно выполнить запрос и получить фактические оценки, вызовите Explain analyze

### View

View - это виртуальная таблица, которую можно создать с помощью команды CREATE OR REPLACE VIEW. На её основе можно делать другие запросы. View не хранит данные, а только лишь выполняет запрос. Materialized view хранят данные на диске, их нужно рефрешить.

### Misc

#### Vacuum

Очищает таблицу от ненужных индексов и мёртвых строк, образовавшихся во время выполнения транзакций. Vacuum analyze расскажет подробно, что и где удалилось. Vacuum full выполнит полную очистку, но придётся заблокировать базу

#### Package

Конкретно в pgsql пакетов нет (есть в postgrespro). В oracle пакет - объект схемы, который группирует логически связанные типы, курсоры, константы, исключения,  глобальные переменные и подпрограммы (процедуры и функции) в единое целое. Кроме того, пакет способен инкапсулировать в себе приватные процедуры, функции и прочее.

#### With as

With as - выполняет временное выражение, результат которого нигде не хранится:

\`\`\`sql
WITH Aeroflot_trips AS (SELECT TRIP.* FROM Company INNER JOIN Trip ON Trip.company = Company.id WHERE name = "Aeroflot")
SELECT plane, COUNT(plane) AS amount FROM Aeroflot_trips GROUP BY plane;
\`\`\`

#### Hypertable

Гипертаблица — это таблица, партицированная по заданному столбцу. Она появляется в расширении TimescaleDB, которое предназначено для работы с временными рядами

#### PostGis

Расширение для pgsql для работы с географическими данными.

#### SELECT COUNT(*) FROM TABLE

Вопрос скорости выполнения COUNT(1) относительно COUNT(*) актуален скорее в теории, т.к. современные SQL-оптимизаторы достаточно интеллектуалы, чтобы обрабатывать оба варианта с одинаковой скоростью. Мнение о том, что COUNT(1) работает быстрее, скорее всего, является пережитком прошлого.

Можно почитать [древний срач на эту тему](https://stackoverflow.com/questions/1221559/count-vs-count1-sql-server)

## SQL Indexes

Индексация даных по некоторому полю (полям) помогает ускорить процесс поиска в таблице по этому полю (полям). Например, база с помощью прохода по B-дереву ищет за O(logn) номер строки, где лежит нужное значение.

Плюсы:
- Ускорение работы селекта
- Блокировки с меньшими затратами
Минусы:
- Занимает лишнее место
- Если сделать индекс на низкоселективное поле (например, bool), можно сделать только хуже
- Увеличивает время вставки, обновления и удаления
- Усложняет перегрузку данных

Индексы также есть и в nosql

Индекс для каждого столбца создавать нет смысла, так как нужно:
- Высокая селективность столбца
- Частое использование столбца в WHERE

Unique индекс автоматически создаётся на PK и поля с unique constaint. Соответственно, создаётся он только для неповторяющихся значений (допускаются несколько null, так как null не равны).

С foreign key всё сложнее: придётся создавать руками. На джаве была замечательная библиотека pg-index-health для проверки в том числе и FK индексов.

Если у WHERE два или больше параметров, можно попытаться использовать составные индексы. 

Индексы внутри базируются на:

- B-дереве - default - применяйте при равенстве или больше/меньше
- Хэше - стоит применять для равенства или сравнения
- GiST - generalized search tree. Используется тогда, когда сортировать нецелесообразно, например, для геометрических объектов. Можно выбрать любой алгоритм разделения
- GIN - для составных типов данных (массив / json bson / tsvector)
- Block Range Index - для таблиц, где столбцы коррелируют с физическим положением (например, если мы храним по возрастанию даты некоторых событий)
- RUM - ещё один индекс для полнотекстового поиска, может быть аналогом GIN

Может возникнуть потребность проиндексировать не все строки из таблицы. Такое может произойти из-за сильной неравномерностью распределения данных, когда редкое значение записи нужно искать по индексу, а частое проще найти полным перебором. Для этого нужно использовать в команде индекса WHERE.

При создании индекса на таблицу устанавливается блокировка SHARE, разрешающая чтение данных, но запрещающая их изменение до завершения индексации. Если таблица крупная и активно используется, сеансы могут долго ожидать освобождения блокировки, что делает этот процесс неприемлемым. Тогда можно создать индекс параллельно c помощью CREATE INDEX CONCURRENTLY
## SQL Transactions

Транзакция - набор запросов, в котором выполняются либо все (COMMIT), либо никакие (ROLLBACK).

БД задает отдельную инструкцию INSERT, UPDATE или DELETE как единицу транзакции.

Транзакция должна удовлетворять ACID:

- A - Atomicity, атомарность: выполняется либо всё, либо ничего, нельзя разбить транзакцию на более мелкие транзакции
- C - Consistency, согласованность: транзакция не нарушит ограничения таблицы
- I - Isolation, изолированность: если транзакции выполняются параллельно, они не должны влиять друг на друга
- D - Durability, долговечность: если транзакция выполнилась, то её результат уже не потеряется, даже при последующих сбоях

PG обеспечивает Durability с помощью Write-Ahead логов (сначала лог, потом запись модификации).

Таблица может блокироваться целиком (с целью синхронизации) или row-level (только конкретные столбцы)

Чтобы прочитать все строки из таблицы, в которой есть заблокированные строки можно использовать SELECT * FROM MyTable WITH (NOLOCK) (приводит к грязному чтению) или читать снапшоты.

Аномалии и уровни изоляций транзакций:
- Потерянное обновление (lost update) - одна транзакция не учла изменений другой. Например, две транзакции параллельно пополняют баланс клиента с 1000 рублей: одна на 100, другая на 200. В итоге первая проставит значение 1100, вторая 1200 - какая последняя закончится, такая и поставит свой результат. Деньги потеряны! Лечится с помощью read_uncommited.
- Грязное чтение (read uncommited) - Транзакция считывает данные, которые ещё не были зафиксированы. Предположим, транзакция А переводит деньги клиента на другой счёт. В это время клиент пытается снять деньги с того счёта другой транзакцией и успешно это делает. Затем транзакция А отменяется и возвращает снятые деньги назад. Деньги потеряны! Лечится с помощью read_commited (дефолт для всех современных СУБД).
- Неповторяемое чтение (non-repeatable read) - транзакция два раза читает значения и получает разные результаты Транзакция А хочет уменьшить баланс счета клиента на 200 денежных единиц. Она проверяет текущее значение суммы на счёте — 500 денежных единиц. В это время транзакция В уменьшает сумму на счёте до 0 и фиксирует изменения. Если бы транзакция А повторно проверила сумму, то получила бы 0 денежных единиц, но на основе первоначальных данных она уже приняла решение уменьшить значение, и счет уходит в минус. Деньги потеряны! Лечится с помощью repeatable_read
- Фантомное чтение (phantom read) - при повторном чтении в рамках одной транзакции одна и та же выборка даёт разные множества строк. Например, правило согласованности запрещает иметь клиенту более 3 лицевых счетов. Для открытия нового счета транзакция А проверяет все счета клиента банка и в результате получает 2 счета. В этот момент транзакция B открывает еще один счет клиенту и фиксирует изменения (3 счета). Если бы транзакция А повторно проверила количество лицевых счетов клиента, то их оказалось бы 3, и по правилу согласованности открытие нового счета было бы невозможно. Лечится с помощью serialazible (база фактически становится однопоточной).
- Аномалия сериализации - результат выполнения параллельных транзакций отличается от результата последовательного их выполнения
Виды блокировок:

- Shared lock - транзакция хочет прочитать данные
- Exclusive lock - транзакция хочет изменить данные
- Update lock - гибрид Shared и Exclusive, транзакция хочет обновить данные
- Intent lock - транзакция хочет получить shared или exclusive на уровне строк
- Schema lock - модифицирует схему или читает метаданные

Распределённые транзакции - нескольким сервисам нужно выполнить свои обновления БД. Если в каком-то из них случилась ошибка (или случилась ошибка при передаче), нужно откатиться, иначе пропадёт консистентность.

2 Phase Commit:

- Prepare Phase. Координатор транзакции отправляет запрос всем участникам (например, базам данных или брокерам сообщений) с просьбой подготовиться к выполнению операции. Участники проверяют возможность выполнения операции и сообщают координатору о своём статусе: «Готов» (Vote Yes), если операция может быть выполнена, или «Не готов» (Vote No), если операция невозможна. Если хотя бы один участник возвращает «Не готов», координатор инициирует откат транзакции. 
- Commit Phase. Если все участники подтвердили готовность, координатор отправляет команду зафиксировать изменения (Commit). Участники фиксируют изменения и подтверждают выполнение операции. Если хотя бы один участник не может выполнить фиксацию, координатор отправляет команду отката (Rollback) всем участникам.

3 Phase Commit:

- Can Commit Phase. Координатор отправляет всем участникам запрос «can commit». Участники отвечают «да» или «нет», указывая на свою готовность. 
- Pre-Commit Phase. Если все участники указывают, что могут зафиксировать транзакцию, координатор говорит им о pre-commit, позволяя подготовиться к финальной фиксации. 
- Commit Phase. После получения ответов на pre-commit, координатор отправляет всем участникам финальную команду «commit». Если любой участник не может pre-commit, выдаётся команда «abort». 

Оркестрация:
Есть один сервис-оркестратор, который запускает транзакции в остальных сервисах и если что-то пошло не так, то вызывает соответствующие компенсирующие транзакции в этих сервисах, при этом выполнение каждого из шагов обновляет текущий статус операции.

Хореография:
Альтернативным решением для Оркестрации является Хореография - где нет оркестратора, управляющего всем процессом. В данном паттерне каждый из сервисов выполняет локальную транзакцию и публикует события, которые вызывают локальные транзакции в остальных сервисах. Каждый компонент системы участвует в принятии решения о судьбе транзакции. 

2PC, 3PC, SAGA: https://habr.com/ru/articles/769102/

## SQL Sharding / Replication

Репликация - дублирование данных, когда данные с одного сервера полностью повторяются на других. Приложения пишут данные в одну базу данных PostgreSQL, а изменения автоматически синхронизируются на другие базы. Позволяет увеличить надёжность и скорость доступа (например, несколько БД в разных странах)

Партиционирование - разделение большой таблицы на маленькие, более управляемые части (партиции).

Требования к ключу: равномерные партиции, максимум 32к партиций, простой поиск по партициям

Шардирование -  метод горизонтального разделения больших баз данных на более управляемые части (разные инстансы), называемые шардами. Каждый шард содержит подмножество данных и может размещаться на отдельных серверах.

Подходы:

- Range-Based - шардирование по диапазонам
- Key-Based - применение хэш-функции к значению
- Directory-Based - имеется каталог с указанием, в каком шарде что лежит

Горизонтальное масштабирование -  разбиение системы на более мелкие структурные компоненты и разнесение их по отдельным физическим машинам (или их группам), и (или) увеличение количества серверов, параллельно выполняющих одну и ту же функцию
Вертикальное масштабирование - увеличение производительности каждого компонента системы с целью повышения общей производительности (добавление мощности к серверу).

Виды репликации:

- При физической репликации на сервер реплики передается поток WAL записей
- Логическая репликация работает по принципу подписки. Мастер сервер выступает в роли поставщика, который публикует изменения, происходящие в базе, а серверы реплики, выступающие в роли подписчиков получают и применяют эти изменения у себя. 

Другой критерий:
- Master-Slave - один главный сервер (Master) и один или несколько подчинённых (Slave). Master принимает все запросы на запись (добавление, изменение, удаление данных), а Slaves только читают данные и получают обновления от Master.
- Master-Master - у базы данных есть два (или больше) главных сервера, и каждый из них может одновременно принимать и обрабатывать запросы на запись и чтение. Данные между серверами автоматически синхронизируются, чтобы оставаться одинаковыми.
## Cache

Кэширование - хранение часто используемых данных как можно ближе с целью ускорения работы с ними. Можно использовать redis или memcached, можно использовать in-memory.

Если кэш наполняется со временем, он называется cold-cache - его надо прогревать. Warm-cache прогревать не надо, он уже заполнен данными

Проблема инвалидации кэша заключается в том, что при изменении данных в основном хранилище нужно изменить их и в кэше

HTTP может кэшировать статику и методы, которые не меняют состояние приложения.

Memcached - простое kv-хранилище, redis может использовать структуры данных сложнее, а также может использоваться как MQ

Алгоритмы вытеснения из кэша:

- LRU - least recently used
- LFU - least frequently used
- RR - random replacement
- FIFO - first in first out, она же очередь.

Правила для ключей редиса:

- Максимум 512МБ
- Разделять через многоточие, например, user:john:roles
- Очень короткие и очень длинные ключи нежелательны
- Не использовать специальные символы
- Понятные имена

## NoSQL

NoSQL - нереляционные базы данных: графовые (neo4j), документоориентированные (mongodb), колончатые (cassandra, clickhouse).

Коллекция в mongodb - группа документов, где хранятся связанные данные
Документ - запись в коллекции, bson(binary json) файл типа ключ-значение

db.collection.Find осуществляет поиск (query - критерии, projection - какие поля вернуть), db.collection.Insert - вставку, db.collection.Update(query - запрос, upsert - создать 
документ если не найден) - редактирование

ObjectId в MongoDB — это уникальный идентификатор документа в коллекции. Он состоит из 12 байт и включает в себя:

Четыре байта времени. Представляют время создания ObjectId в секундах с момента эпохи Unix.
Три байта с id машины
Два байта с id процесса
Три байта счётчика. Устанавливается случайное значение и увеличивается для каждого ObjectId, сгенерированного в одном процессе

Lookup в MongoDB - позволяет делать джойны между коллекциями
Change streams - позволяет подписываться на обновления в реальном времени

### BASE

- Basically available - Система должна быть доступна для обработки запросов и предоставления данных в любое время, даже в случае сбоев в работе или разделения на несколько частей
- Soft state - Состояние системы может быть временно несогласованным, то есть данные могут находиться в процессе изменения и обновления.
- Eventual consistency - В системе может быть временная несогласованность данных, но в конечном итоге все данные будут согласованы.

### CAP-теорема

Для любой распределённой системы выберите только два из трёх:

- Consistency - согласованность данных
- Availability - любой запрос к распределённой системе завершается корректным откликом, однако без гарантии, что ответы всех узлов системы совпадают
- Partition tolerance - расщепление распределённой системы на несколько изолированных секций не приводит к некорректности отклика от каждой из секций.

### Индексы в нереляционных БД

- Первичные индексы (на основе ключей)
- Вторичные индексы (на основе полей)
- Индексы на основе диапазонов
- Геопространственные индексы
- Полнотекствоые индексы


### Сравнение различных баз

#### Документоориентированные

Данные хранятся в коллекциях документов.

Как правило, для этого используются форматы JSON, XML или BSON. Одна запись может включать в себя сколько угодно данных любых типов, ограничения отсутствуют. Внутри одного документа существует внутренняя структура, но от одного документа к другому она может различаться. Кроме того, документы можно друг в друга вкладывать. 

Преимущество документоориентированных баз данных в том, что они обладают высокой доступностью и гибкостью данных. В любой документ можно записать абсолютно любой набор данных.

Пример: MongoDB
#### Графовые

Данные хранятся в графовой структуре. Граф состоит из вершин (узлов) и рёбер (связей), которые соединяют эти вершины. Вершины представляют сущности (объекты), а рёбра — отношения между ними.

Примеры приложений, в которых используются графовые базы данных: рекомендательные системы, сервисы для анализа социальных сетей, выявление мошенничества, маршрутизация, моделирование знаний.

Пример: Neo4j

#### Key-value

Обычно используются для кэшей, предоставляют доступ к тому или иному значению по уникальному ключу.

Пример: Memcached, Redis

#### Колоночные

Применяются как правило в аналитических системах класса business intelligence (ROLAP) и аналитических хранилищах данных (data warehouses). 

Данные хранятся и организкются не по строкам, как в SQL, а по колонкам, что упрощает работу с большим количеством данных. 

Примеры: ClickHouse, Cassandra

Колоночные таблицы обычно хорошо подходят для аналитических и OLAP задач, где требуется обработка больших объёмов данных. 
            `
            const marked = new Marked(
								  markedHighlight({
									emptyLangClass: 'hljs',
									langPrefix: 'hljs language-',
									highlight(code, lang, info) {
									  const language = hljs.getLanguage(lang) ? lang : 'plaintext';
									  return hljs.highlight(code, { language }).value;
									}
								  })
								);
            const html = marked.parse(markdown);
            
            document.getElementById('html-output').innerHTML = html;
        }
	convertMarkdown()
    </script>
</body>
</html>          