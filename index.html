<!DOCTYPE html><html lang="ru"><head>    <meta charset="UTF-8">    <meta name="viewport" content="width=device-width, initial-scale=1.0">    <title>leetbase</title>	<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.5.1/styles/github.min.css">    <style>        body {            font-family: Arial, sans-serif;            margin: 10px 0 10px 0;        }        #html-output {            margin-bottom: 20px;			margin-left: auto;			margin-right: auto;			width: 40vw;			border: 1px solid gray;			border-radius:12px;			padding-left: 10px;			padding-right: 10px;        }				@media (max-width: 768px) {			#html-output {				width: 90vw !important;			}		}    </style></head><body>    <div id="html-output"></div>	<script src="https://cdn.jsdelivr.net/npm/marked/lib/marked.umd.js"></script>	<script src="https://cdn.jsdelivr.net/npm/marked-highlight/lib/index.umd.js"></script>    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.5.1/highlight.min.js"></script>    <script>        function convertMarkdown() {			const { Marked } = globalThis.marked;			const { markedHighlight } = globalThis.markedHighlight;            const markdown = `# База по литкодуЗдесь собраны все базовые задачи с литкода## Linked Lists### [Merge k sorted lists (hard)](https://leetcode.com/problems/merge-k-sorted-lists/)Хз, чё в ней сложного#### Постановка задачиДано k отсортированных односвязных списков. Необходимо слить их в один (тоже отсортированный).Пример:\`\`\`jsInput: lists = [[1,4,5],[1,3,4],[2,6]]Output: [1,1,2,3,4,4,5,6]\`\`\`#### Решение в лоб Описание элемента односвязного списка имеет вид:\`\`\`go type ListNode struct {    Val int    Next *ListNode } \`\`\`На вход поступает массив указателей на первые элементы списков. Первым делом найдём элемент, который должен стать головой. Для этого перебираем все указатели на первые элементы и ищем минимальный. Паралелльно ведём счётчик указателей равных nil. Если их столько же, сколько и всего в массиве - завершаем работу. Если мы забираем какой-либо элемент из списка, указатель на голову надо подвинуть на Next.\`\`\`gofunc mergeKLists(lists []*ListNode) *ListNode {    // Если массив пустой - вернуть nil    if (len(lists) == 0) {        return nil    }    // Здесь мы будем хранить текущий элемент и голову, а также количество пустых списков    var head *ListNode;     var curr *ListNode = nil;    var emptyCount = 0;    // Здесь мы будем хранить сведения о минимальном на данном этапе значении    var minVal int = 10e5;    var minNode *ListNode;    minIdx := 0    // Ищем голову списка    for i := 0; i < len(lists); i++ {        if ((lists[i] != nil) && (lists[i].Val < minVal)) {            minVal = lists[i].Val            minIdx = i        }         if (lists[i] == nil) {            emptyCount++ // Считаем пустые списки        }    }    // Если все списки пустые - вернуть nil    if (emptyCount == len(lists)) {        return nil    }    // Записываем голову списка    minNode = lists[minIdx]    lists[minIdx] = lists[minIdx].Next    if (lists[minIdx] == nil) {        emptyCount++    }    head = minNode    curr = head    // То же самое для остальных элементов    for (emptyCount != len(lists)) {        emptyCount = 0        var minVal int = 10e5        for i := 0; i < len(lists); i++ {            if ((lists[i] != nil) && (lists[i].Val < minVal)) {                minVal = lists[i].Val                minIdx = i            }             if (lists[i] == nil) {                emptyCount++            }        }        minNode = lists[minIdx]        lists[minIdx] = lists[minIdx].Next        if (lists[minIdx] == nil) {            emptyCount++        }        curr.Next = minNode        curr = curr.Next    }    return head}\`\`\`Получилась сложность O(n^2), литкод говорит, что ты мудак. Нужно другое решение#### Адекватное решениеБудем мёрджить не всё сразу, а попарно. Поскольку смёрджить два списка можно за логарифм, итоговая сложность будет O(nlogn)\`\`\`gofunc mergeKLists(lists []*ListNode) *ListNode {    if len(lists) == 0 {        return nil    }    // пока листов больше чем один - выкидываем их из общего списка, мёрджим и закидываем в конец (так быстрее)    for len(lists) > 1 {        l1 := lists[0]        l2 := lists[1]        lists = lists[2:]        lists = append(lists, mergeTwoLists(l1, l2))    }    return lists[0]}func mergeTwoLists(list1 *ListNode, list2 *ListNode) *ListNode {    var head *ListNode    var curr *ListNode    if (list1 == nil) {        return list2    } else if (list2 == nil) {        return list1    } else if (list1.Val < list2.Val) {        head = list1        list1 = list1.Next    } else {        head = list2        list2 = list2.Next    }    for (list1 != nil && list2 != nil) {        if (list1.Val < list2.Val) {            curr.Next = list1            curr = curr.Next            list1 = list1.Next        } else {            curr.Next = list2            curr = curr.Next            list2 = list2.Next        }    }     if (list1 != nil) {        for (list1 != nil) {            curr.Next = list1            curr = curr.Next            list1 = list1.Next        }    } else if (list2 != nil) {        for (list2 != nil) {            curr.Next = list2            curr = curr.Next            list2 = list2.Next        }    }    return head}\`\`\`Runtime 0ms Beats 100.00%Memory 6.69MB Beats 72.01%Умные люди укладываются в 6.4, но пойдёт### [Reverse linked list (easy)](https://leetcode.com/problems/reverse-linked-list/)####Самая базовая задача, спросят 100%, если не ответишь, даже не будут общаться дальше.#### Постановка задачиДан указатель на первый элемент односвязного списка. Необходимо развернуть его и вернуть указатель на новый первый элемент.Пример:\`\`\`jsInput: head = [1,2,3,4,5]Output: [5,4,3,2,1]\`\`\`#### РешениеОписание элемента односвязного списка имеет вид:\`\`\`go type ListNode struct {    Val int    Next *ListNode }\`\`\`Чтобы решить данную задачу, необходимо каждому из элементов списка поменять значение поля "Next", подставив вместо следующего элемента предыдущий (соответственно, для первого элемента - nil). Таким образом, для "1" Next - nil, для "2" - "1", и так далее.Если список пустой (head==nil), возвращаем nil\`\`\`gofunc reverseList(head *ListNode) *ListNode {    // Если список пустой - возвращаем nil    if head == nil {        return nil    }    // Здесь мы будем хранить текущий и следующий элементы    var curr *ListNode = head    var next *ListNode = head.Next        // Головному элементу в качестве следующего задаём nil    head.Next = nil    // Пока следующий(next) элемент не nil, меняем его next на текущий(curr)    for (next != nil) {        var tmp *ListNode = next.Next        next.Next = curr        curr = next        next = tmp    }        // Возвращаем последний текущий элемент    return curr}\`\`\`Можно сделать немного элегантнее:\`\`\`gofunc reverseList(head *ListNode) *ListNode {    var newHead *ListNode    curr := head    for curr != nil{        newHead, curr, curr.Next = curr, curr.Next, newHead    }    return newHead}\`\`\`P. S. В условии сказано, что задачу можно решить рекурсией, но предлагающих решать такие задачи рекурсией надо сразу слать нахуй, так как рекурсия с неограниченной глубиной - верный путь к отвалу.	`            const marked = new Marked(								  markedHighlight({									emptyLangClass: 'hljs',									langPrefix: 'hljs language-',									highlight(code, lang, info) {									  const language = hljs.getLanguage(lang) ? lang : 'plaintext';									  return hljs.highlight(code, { language }).value;									}								  })								);            const html = marked.parse(markdown);                        document.getElementById('html-output').innerHTML = html;        }	convertMarkdown()    </script></body></html>